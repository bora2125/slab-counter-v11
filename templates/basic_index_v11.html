<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AZA Slab Counter v11.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
            background: #ffffff;
            color: #333;
            min-height: 100vh;
            padding: 0;
            line-height: 1.6;
        }

        .container {
            width: 100%;
            height: 100vh;
            margin: 0;
            background: #ffffff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-radius: 0;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.1);
        }

        .app-title {
            background: #1947BA;
            color: white;
            padding: 1px 25px;
            border-radius: 0;
            margin-bottom: 0;
            text-align: left;
            box-shadow: 0 8px 32px rgba(25, 71, 186, 0.4);
            border-bottom: 1px solid #dee2e6;
            backdrop-filter: blur(10px);
        }

        .app-title h1 {
            font-size: 1.5em;
            margin-bottom: 3px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .app-title p {
            margin: 0;
            font-size: 0.8em;
            opacity: 0.9;
        }

        .version-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            margin-left: 10px;
            font-weight: bold;
        }

        .content {
            padding: 20px;
            flex: 1;
            overflow: hidden;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 380px 1fr 380px;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            padding-right: 10px;
            scrollbar-width: thin;
            scrollbar-color: #1947BA #ffffff;
        }
        
        .left-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .left-panel::-webkit-scrollbar-track {
            background: #ffffff;
            border-radius: 4px;
        }
        
        .left-panel::-webkit-scrollbar-thumb {
            background: #1947BA;
            border-radius: 4px;
        }
        
        .left-panel::-webkit-scrollbar-thumb:hover {
            background: #008759;
        }

        .center-panel {
            display: flex;
            flex-direction: column;
            gap: 1px;
            overflow-y: auto;
            height: 100%;
            position: relative;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            padding-right: 10px;
            scrollbar-width: thin;
            scrollbar-color: #1947BA #ffffff;
        }
        
        .right-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .right-panel::-webkit-scrollbar-track {
            background: #ffffff;
            border-radius: 3px;
        }
        
        .right-panel::-webkit-scrollbar-thumb {
            background: #1947BA;
            border-radius: 3px;
        }

        .upload-section {
            border: 3px dashed #1947BA;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            height: fit-content;
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%);
            position: relative;
        }

        .upload-progress {
            display: none;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .upload-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 600;
        }

        .upload-progress-bar-container {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .upload-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #1947BA 0%, #008759 100%);
            transition: width 0.3s ease;
            width: 0%;
            border-radius: 10px;
        }

        .upload-progress-text {
            display: none;
        }

        .upload-status {
            margin-top: 15px;
            font-size: 12px;
            color: #666;
            min-height: 16px;
        }

        .upload-section:hover {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.1) 0%, rgba(104, 109, 224, 0.1) 100%);
            border-color: #1947BA;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(72, 52, 212, 0.2);
        }

        .upload-section.dragover {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.15) 0%, rgba(104, 109, 224, 0.15) 100%);
            border-color: #008759;
            transform: scale(1.02);
        }

        .file-input {
            display: none;
        }

        .btn {
            background: #1947BA;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            margin: 8px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.5);
            background: #1947BA;
        }

        .btn:disabled {
            background: #393D47;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            opacity: 0.6;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%);
            border-radius: 10px;
            border: 1px solid #1947BA;
        }

        .slider-container {
            width: 100%;
        }
        
        .confidence-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            width: 100%;
        }
        
        .confidence-controls label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            margin: 0;
        }
        
        .confidence-input {
            width: 55px;
            padding: 6px 2px;
            border: 1px solid #ccc;
            border-radius: 6px;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            background: white;
            flex-shrink: 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1947BA;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(72, 52, 212, 0.3);
        }

        .single-image-container {
            width: 100%;
        }

        .preview-section {
            display: none;
        }

        .result-section {
            display: none;
        }

        .preview-info {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.1) 0%, rgba(104, 109, 224, 0.1) 100%);
            border: 1px solid #1947BA;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .result-info {
            background: #f0f8f0;
            border: 1px solid #008759;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .result-info.error {
            background: #ffe8e8;
            border-color: #f44336;
        }


        .image-container {
            position: relative;
            display: inline-block;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 15px;
            background: #f9f9f9;
            overflow: hidden;
            min-height: 700px;
            width: 100%;
            text-align: center;
        }

        .image-container img {
            max-width: 100%;
            max-height: 700px;  
            border-radius: 8px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            cursor: zoom-in;
            transition: transform 0.3s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .image-container.edit-mode img {
            cursor: crosshair;
        }

        .point {
            position: absolute;
            width: 11px;
            height: 11px;
            border-radius: 50%;
            border: 1px solid white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 6px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            z-index: 10;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .point.original {
            background-color: #ff0000;
        }

        .point.manual {
            background-color: #00ff00;
        }

        .point.selected {
            background-color: #ffff00;
            border: 2px solid #ff6600;
        }

        .point.batch {
            color: white;
            border: 2px solid white;
            font-weight: bold;
        }

        .selection-rectangle {
            position: absolute;
            border: 2px dashed #ff6600;
            background: rgba(255, 102, 0, 0.1);
            pointer-events: none;
            z-index: 15;
            display: none;
        }

        .mode-selector {
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.1) 0%, rgba(104, 109, 224, 0.1) 100%);
            border: 1px solid #1947BA;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 1px;
        }

        .mode-selector h4 {
            margin-bottom: 10px;
            color: #393D47;
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mode-btn {
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 6px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #1947BA;
            color: white;
            border-color: #4834d4;
            box-shadow: 0 2px 8px rgba(72, 52, 212, 0.3);
        }

        .batch-controls {
            display: none;
            margin-top: 10px;
        }

        .batch-controls.active {
            display: block;
        }

        .batch-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }

        .batch-input {
            width: 80px;
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .assign-btn {
            background: #1947BA;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .assign-btn:hover {
            background: #008759;
            transform: translateY(-1px);
        }

        .assign-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .point:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #1947BA;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            font-weight: bold;
            z-index: 10000;
            max-width: 400px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            animation: slideInRight 0.3s ease-out;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .alert button:hover {
            background-color: rgba(255, 255, 255, 0.2) !important;
            transform: scale(1.1);
        }

        @keyframes slideInRight {
            0% {
                transform: translateX(100%);
                opacity: 0;
            }
            100% {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            background: #ffffff;
            color: #046648;
            border: 1px solid #008759;
        }

        .alert-error {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #f44336;
        }

        .alert-warning {
            background: #fff8e1;
            color: #f57c00;
            border: 1px solid #ffb74d;
        }
        
        /* Modal para número de lote */
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s, color 0.2s;
        }
        
        .modal-close-btn:hover {
            background-color: rgba(0, 0, 0, 0.1);
            color: #333;
        }
        
        .modal-close-btn:active {
            background-color: rgba(0, 0, 0, 0.2);
        }

        /* Navegación entre imágenes */
        .image-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 5px;
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(25, 71, 186, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%);
            border: 1px solid #e0e6ff;
            border-radius: 6px;
            gap: 12px;
        }

        .nav-arrow {
            background: #1947BA;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            min-width: 88px;
            justify-content: center;
        }

        .nav-arrow:hover {
            background: #008759;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 71, 186, 0.3);
        }

        .nav-arrow:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(25, 71, 186, 0.2);
        }

        .nav-arrow:disabled {
            background: #ccc;
            color: #999;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .nav-arrow:disabled:hover {
            background: #ccc;
            transform: none;
            box-shadow: none;
        }

        .image-counter {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            background: white;
            padding: 6px 12px;
            border-radius: 16px;
            border: 1px solid #ddd;
            min-width: 64px;
            text-align: center;
        }
        .batch-modal {
            display: none;
            position: fixed;
            z-index: 20000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease-out;
            align-items: center;
            justify-content: center;
        }
        
        .batch-modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            width: 400px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            text-align: center;
            animation: slideInDown 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        @keyframes slideInDown {
            0% {
                transform: translateY(-50px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .batch-modal h3 {
            margin: 0 0 20px 0;
            color: #393D47;
            font-size: 1.3em;
        }
        
        .batch-modal-input {
            width: 120px;
            padding: 12px 15px;
            border: 2px solid #1947BA;
            border-radius: 8px;
            font-size: 1.2em;
            text-align: center;
            margin: 20px 0;
            font-weight: bold;
        }
        
        .batch-modal-input:focus {
            outline: none;
            border-color: #1947BA;
            box-shadow: 0 0 10px rgba(72, 52, 212, 0.3);
        }
        
        /* Modal eliminado - solo mantenemos sistema de persistencia sin intervención del usuario */
        
        .batch-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .batch-modal-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .batch-modal-btn.confirm {
            background: #1947BA;
            color: white;
        }
        
        .batch-modal-btn.confirm:hover {
            background: #393D47;
            transform: translateY(-2px);
        }
        
        .batch-modal-btn.cancel {
            background: #e9ecef;
            color: #495057;
        }
        
        .batch-modal-btn.cancel:hover {
            background: #dee2e6;
        }
        
        /* Estilos para modal centrado */
        .movable-modal {
            position: relative !important;
            margin: 0 auto !important;
        }
        
        /* Asegurar que el modal esté centrado */
        .batch-modal.centered {
            display: flex !important;
            align-items: center;
            justify-content: center;
        }

        /* Centrado mejorado para modal de limpieza - solo cuando está visible */
        .batch-modal[style*="flex"] {
            align-items: center;
            justify-content: center;
        }

        .batch-modal-content.wide {
            width: 85%;
            max-width: 1200px;
        }

        img {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
        }

        .image-container img {
            -webkit-context-menu: none;
            -moz-context-menu: none;
            context-menu: none;
        }

        .image-container {
            position: relative;
        }

        .image-container::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 40px;
            height: 40px;
            background: transparent;
            pointer-events: none;
            z-index: 5;
        }

        .images-list-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            backdrop-filter: blur(10px);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .section-header h3 {
            margin: 0;
            color: #333;
            font-weight: 600;
            font-size: 16px;
        }

        .section-header h4 {
            margin: 0;
            color: #333;
            font-size: 16px;
            font-weight: 600;
        }

        .images-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            max-height: 220px;
            overflow-y: auto;
        }

        .image-card {
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .image-card:hover {
            border-color: #4834d4;
            box-shadow: 0 2px 8px rgba(72, 52, 212, 0.2);
        }

        .image-card.active {
            border-color: #4834d4;
            background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%);
            box-shadow: 0 2px 8px rgba(72, 52, 212, 0.2);
        }

        .image-card-content {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .image-card .image-name {
            font-size: 12px;
            color: #393D47;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-card .image-status {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            display: inline-block;
            width: fit-content;
            font-weight: 500;
        }

        .image-status.uploaded {
            background: #e8f5e8;
            color: #046648;
        }

        .image-status.detected {
            background: #e3f2fd;
            color: #1565c0;
        }

        .image-status.with-batches {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .image-status.editing {
            background: #fff3e0;
            color: #ef6c00;
        }

        .image-card-buttons {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            gap: 4px;
            align-items: center;
        }

        .image-card:hover .image-card-buttons {
            display: flex;
        }

        .image-card .delete-btn {
            background: rgba(255, 71, 87, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-card .clean-data-btn {
            background: rgba(255, 193, 7, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .image-card .clean-data-btn:hover {
            background: rgba(255, 193, 7, 1);
            transform: scale(1.1);
        }

        .image-card .delete-btn:hover {
            background: rgba(255, 71, 87, 1);
            transform: scale(1.1);
        }

        .active-image-section {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(72, 52, 212, 0.1);
        }

        .image-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            background: #1947BA;
            color: white;
            border: none !important;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            background: #008759;
            transform: translateY(-1px);
        }

        .btn-small:focus {
            outline: none !important;
            border: none !important;
            box-shadow: none !important;
        }

        .delete-batch-btn {
            background: white !important;
            color: #ff4757 !important;
            padding: 4px 8px !important;
            font-size: 10px !important;
            margin-left: 10px !important;
            border: 0 !important;
            border-width: 0 !important;
            border-style: none !important;
            border-color: transparent !important;
            outline: 0 !important;
            outline-width: 0 !important;
            outline-style: none !important;
            outline-color: transparent !important;
            box-shadow: none !important;
            border-radius: 4px !important;
            cursor: pointer !important;
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
        }

        .delete-batch-btn:hover {
            background: #ffffff !important;
            border: 0 !important;
            outline: 0 !important;
            box-shadow: none !important;
        }

        .delete-batch-btn:focus {
            background: white !important;
            border: 0 !important;
            border-width: 0 !important;
            border-style: none !important;
            border-color: transparent !important;
            outline: 0 !important;
            outline-width: 0 !important;
            outline-style: none !important;
            outline-color: transparent !important;
            box-shadow: none !important;
        }

        .delete-batch-btn:active {
            background: white !important;
            border: 0 !important;
            border-width: 0 !important;
            border-style: none !important;
            border-color: transparent !important;
            outline: 0 !important;
            outline-width: 0 !important;
            outline-style: none !important;
            outline-color: transparent !important;
            box-shadow: none !important;
        }

        .no-images-message {
            grid-column: 1 / -1;
        }

        .active-image-info {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(72, 52, 212, 0.1);
        }

        .active-image-details {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            padding: 4px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-row strong {
            color: #393D47;
        }

        .detail-row span {
            color: #666;
        }

        .batch-details {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            box-shadow: 0 2px 10px rgba(72, 52, 212, 0.1);
        }

        .batch-detail-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .batch-detail-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 11px;
        }

        .batch-detail-item .batch-number {
            font-weight: bold;
            color: #393D47;
        }

        .batch-detail-item .batch-count {
            color: #666;
            font-size: 10px;
            background: #e9ecef;
            padding: 2px 6px;
            border-radius: 10px;
        }

        /* Toggle de tema */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: white;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }


    </style>
</head>
<body>
    <div class="container">
        <div class="content">
            <div class="main-layout">
                <!-- Panel Izquierdo: Controles -->
                <div class="left-panel">
                    <!-- Título de la aplicación -->
                    <div class="app-title">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 15px;">
                            <img src="logo_aza.JPG" alt="AZA Logo" style="height: 75px; width: auto;">
                            <span class="version-badge">Latest v11.0</span>
                        </div>
                    </div>
                    
                    
                    <!-- Sección de subida -->
                    <div class="upload-section" id="uploadArea">
                        <h3>📸 Subir Imágenes</h3>
                        <p>Arrastra múltiples imágenes aquí o haz click para seleccionar</p>
                        <button class="btn" onclick="document.getElementById('fileInput').click()">
                            Seleccionar Imágenes
                        </button>
                        <input type="file" id="fileInput" class="file-input" 
                               accept=".jpg,.jpeg,.png,.bmp,.tiff,.webp" multiple>
                        <div id="uploadStatus" class="upload-status"></div>
                        <div class="upload-progress" id="uploadProgress">
                            <div class="upload-progress-header">
                                <span>📤 Subiendo imágenes...</span>
                                <span id="uploadProgressPercent">0%</span>
                            </div>
                            <div class="upload-progress-bar-container">
                                <div class="upload-progress-bar" id="uploadProgressBar"></div>
                                <div class="upload-progress-text" id="uploadProgressText">Preparando...</div>
                            </div>
                        </div>
                    </div>

                    <!-- Controles -->
                    <div class="controls">
                        <div class="slider-container">
                            <div class="confidence-controls">
                                <label>Confidence Threshold:</label>
                                <input type="range" id="confidenceSlider" class="slider" 
                                       min="0.1" max="1.0" step="0.01" value="0.60" style="flex: 1; min-width: 120px;">
                                <input type="number" id="confidenceInput" class="confidence-input" 
                                       min="0.1" max="1.0" step="0.01" value="0.60">
                            </div>
                        </div>
                        <button id="detectBtn" class="btn" onclick="detectSlabs()" disabled>
                            🚀 DETECTAR PALANQUILLAS
                        </button>
                    </div>

                    <!-- Selector de Modo de Edición -->
                    <div class="mode-selector" id="modeSelector" style="display: none;">
                        <h4>🔧 Modo de Edición</h4>
                        <div class="mode-buttons">
                            <div class="mode-btn" id="slabsMode" onclick="switchEditMode('slabs')">
                                ✏️ Editar Slabs
                            </div>
                            <div class="mode-btn active" id="batchesMode" onclick="switchEditMode('batches')">
                                📦 Selección de Lotes
                            </div>
                        </div>
                        
                        <!-- Instrucciones dinámicas según modo -->
                        <div class="mode-instructions" id="modeInstructions">
                            <div id="slabsInstructions" style="display: none;">
                                <div style="background: #e8f5e8; border: 1px solid #c3e6c3; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                                    <div style="font-weight: bold; color: #008759; margin-bottom: 8px; text-align: center;">
                                        ✏️ MODO: EDICIÓN DE SLABS
                                    </div>
                                    <div style="font-size: 12px; color: #555; line-height: 1.4;">
                                        <div style="margin-bottom: 5px;">
                                            <strong>🖱️ Controles:</strong>
                                        </div>
                                        <div style="margin-left: 8px;">
                                            • <strong>Click izquierdo:</strong> Agregar nueva palanquilla<br>
                                            • <strong>Click derecho:</strong> Eliminar palanquilla cercana<br>
                                            • <strong>CTRL + Arrastrar:</strong> Navegar por la imagen<br>
                                            • <strong>Rueda del mouse:</strong> Zoom in/out
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div id="batchesInstructions">
                                <div style="background: #e8f0ff; border: 1px solid #b3d9ff; border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                                    <div style="font-weight: bold; color: #1947BA; margin-bottom: 8px; text-align: center;">
                                        📦 MODO: SELECCIÓN DE LOTES
                                    </div>
                                    <div style="font-size: 12px; color: #555; line-height: 1.4;">
                                        <div style="margin-bottom: 5px;">
                                            <strong>🖱️ Controles:</strong>
                                        </div>
                                        <div style="margin-left: 8px;">
                                            • <strong>Arrastrar:</strong> Dibujar área libre para seleccionar<br>
                                            • <strong>Crear lote:</strong> Asignar número al grupo seleccionado<br>
                                            • <strong>Navegación:</strong> CTRL + Arrastrar o rueda del mouse
                                        </div>
                                        <div style="margin-top: 10px; font-size: 11px; color: #888; background: #f8f9fa; padding: 8px; border-radius: 5px;">
                                            <strong>💡 Nota:</strong> En este modo no se pueden editar palanquillas individuales
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Controles de lotes -->
                                <div class="batch-controls" id="batchControls">
                                    <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                                        📦 <strong>Gestión de Lotes</strong>
                                    </div>
                                    
                                    <!-- Crear nuevo lote -->
                                    <div class="batch-creation" style="margin-bottom: 15px; padding: 10px; background: linear-gradient(135deg, rgba(72, 52, 212, 0.05) 0%, rgba(104, 109, 224, 0.05) 100%); border-radius: 5px;">
                                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                                            1. Arrastra para seleccionar slabs
                                        </div>
                                        <div class="batch-input-group" style="display: none;">
                                            <button class="assign-btn" id="assignBatchBtn" onclick="openBatchModal()" disabled>
                                                📦 Crear Lote
                                            </button>
                                        </div>
                                        <div style="font-size: 11px; color: #666; text-align: center; padding: 10px; background: #f8f9fa; border-radius: 5px; margin-top: 10px;">
                                            📝 <strong>Instrucción:</strong><br>
                                            Dibuja un área para seleccionar slabs.<br>
                                            El popup de lote aparecerá automáticamente.
                                        </div>
                                        <div style="font-size: 10px; color: #888; margin-top: 5px;">
                                            Slabs seleccionados: <span id="selectedCount">0</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Indicador de Estado de Persistencia -->
                    <div class="save-status-indicator" id="saveStatusIndicator" style="margin-bottom: 15px; padding: 10px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border-left: 4px solid #28a745; display: none;">
                        <div style="font-size: 12px; font-weight: 600; color: #155724; margin-bottom: 5px;">
                            💾 Estado de Persistencia
                        </div>
                        <div id="saveStatusText" style="font-size: 11px; color: #495057;">
                            Sistema inicializado
                        </div>
                        <div id="lastSaveTime" style="font-size: 10px; color: #6c757d; margin-top: 3px;">
                            Último guardado: Nunca
                        </div>
                    </div>

                    <!-- Loading -->
                    <div class="loading" id="loading">
                        <div class="spinner"></div>
                        <p>Procesando imagen con IA...</p>
                    </div>
                </div>

                <!-- Panel Central: Visualización de Imagen -->
                <div class="center-panel">
                    <!-- Controles de Zoom y Paneo -->
                    <div class="image-controls" id="imageControls" style="display: none;">
                        <div class="control-label">Zoom</div>
                        <div class="control-group">
                            <button class="control-btn" onclick="zoomIn()" title="Acercar (+)">
                                +
                            </button>
                            <div class="zoom-level" id="zoomLevel">100%</div>
                            <button class="control-btn" onclick="zoomOut()" title="Alejar (-)">
                                −
                            </button>
                        </div>
                        <div class="control-separator"></div>
                        <div class="control-group">
                            <button class="control-btn" onclick="resetZoom()" title="Restablecer zoom (0)">
                                🎯
                            </button>
                            <button class="control-btn" onclick="fitToScreen()" title="Ajustar a pantalla (F)">
                                📱
                            </button>
                        </div>
                        <div class="control-separator"></div>
                        <div class="control-label">Pan</div>
                        <div class="control-group">
                            <button class="control-btn" onclick="centerImage()" title="Centrar imagen (C)">
                                ⌖
                            </button>
                        </div>
                    </div>
                    <!-- Preview de imagen activa -->
                    <div class="preview-section" id="previewSection" style="display: none;">
                        <div class="section-header">
                            <h3>📷 Vista Previa</h3>
                            <div id="activeImageTitle" style="font-size: 12px; color: #666;">
                                Imagen cargada
                            </div>
                        </div>
                        <div class="image-container" id="previewContainer">
                            <p style="text-align: center; color: #999; padding: 60px;">
                                Vista previa aparecerá aquí
                            </p>
                        </div>
                    </div>

                    <!-- Resultados de imagen activa -->
                    <div class="result-section" id="resultSection" style="display: none;">
                        <div class="section-header">
                            <h3>🎯 Detección y Edición</h3>
                            <div class="image-actions">
                                <button id="previewBtn" class="btn-small" onclick="previewCurrentImage()" style="background: #1947BA;">
                                    👁️ Ver Original
                                </button>
                            </div>
                        </div>
                        <div class="image-container" id="imageContainer">
                            <p style="text-align: center; color: #999; padding: 60px;">
                                La imagen procesada aparecerá aquí
                            </p>
                        </div>
                    </div>

                    <!-- Navegación entre imágenes -->
                    <div class="image-navigation" id="imageNavigation" style="display: none;">
                        <button class="nav-arrow nav-prev" id="prevImageBtn" onclick="previousImage()" title="Imagen anterior">
                            ⬅️ Anterior
                        </button>
                        <div class="image-counter" id="imageCounter">
                            <span id="currentImageIndex">1</span> de <span id="totalImages">1</span>
                        </div>
                        <button class="nav-arrow nav-next" id="nextImageBtn" onclick="nextImage()" title="Imagen siguiente">
                            Siguiente ➡️
                        </button>
                    </div>

                    <!-- Mensaje cuando no hay imagen seleccionada -->
                    <div class="no-active-image" id="noActiveImage">
                        <div style="text-align: center; color: #999; padding: 100px 20px;">
                            <h3>📷 No hay imagen seleccionada</h3>
                            <p>Sube imágenes desde el panel izquierdo y selecciona una desde el panel derecho para comenzar</p>
                        </div>
                    </div>
                </div>

                <!-- Panel Derecho: Gestión de Imágenes -->
                <div class="right-panel">
                    <!-- Botones de gestión -->
                    <div style="margin-bottom: 20px; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">
                        <button class="btn" onclick="mostrarTablaHistorica()" style="font-size: 12px; padding: 8px 10px; background: #1947BA; border: none; border-radius: 6px; color: white; cursor: pointer;">
                            📊 Ver Histórico
                        </button>
                        <button class="btn" onclick="forceBackup()" style="font-size: 12px; padding: 8px 10px; background: #fd7e14; border: none; border-radius: 6px; color: white; cursor: pointer;">
                            💾 Forzar Respaldo
                        </button>
                        <button class="btn" onclick="openCleanDatabaseModal()" style="font-size: 12px; padding: 8px 10px; background: #dc3545; border: none; border-radius: 6px; color: white; cursor: pointer;">
                            🗑️ Limpiar BD
                        </button>
                    </div>

                    <!-- Gestión de Imágenes -->
                    <div class="images-list-section">
                        <div class="section-header">
                            <h3>📂 Gestión de Imágenes</h3>
                            <div id="totalImagesCount" style="font-size: 11px; color: #666; display: none;">
                                Total: 0 imágenes
                            </div>
                        </div>
                        
                        <!-- Filtro por estado -->
                        <div class="filter-section" style="margin-bottom: 15px;">
                            <div style="font-size: 12px; font-weight: bold; color: #30336b; margin-bottom: 8px;">
                                🔍 Filtrar por Estado:
                            </div>
                            <select id="statusFilter" onchange="filterImagesByStatus()" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                                <option value="all" selected>Todas las imágenes</option>
                                <option value="uploaded">Cargado</option>
                                <option value="detected">Detectado</option>
                                <option value="with_batches">Con lotes</option>
                            </select>
                        </div>
                        
                        <div class="images-grid" id="imagesGrid">
                            <div class="no-images-message">
                                <p style="text-align: center; color: #999; padding: 20px; font-size: 12px;">
                                    📷 No hay imágenes<br>
                                    <small>Sube desde panel izquierdo</small>
                                </p>
                            </div>
                        </div>
                    </div>


                    
                    <!-- Info de Imagen Activa -->
                    <div class="active-image-info" id="activeImageInfo" style="display: none;">
                        <div class="section-header">
                            <h4>🎯 Imagen Activa</h4>
                        </div>
                        <div class="active-image-details" id="activeImageDetails">
                            <div class="detail-row" style="display: none;">
                                <strong>Nombre:</strong> <span id="activeImageName">-</span>
                            </div>
                            <div class="detail-row" style="display: none;">
                                <strong>Estado:</strong> <span id="activeImageStatus">-</span>
                            </div>
                            <div class="detail-row">
                                <strong>Slabs en Lotes:</strong> <span id="activeImageSlabs">0</span>
                            </div>
                            <div class="detail-row">
                                <strong>Lotes:</strong> <span id="activeImageBatches">-</span>
                            </div>
                        </div>
                        
                        <!-- Detalle de slabs por lote -->
                        <div class="batch-details" id="batchDetails" style="display: none;">
                            <div class="section-header" style="margin-bottom: 10px;">
                                <h5 style="margin: 0; color: #30336b;">📊 Detalle por Lote</h5>
                            </div>
                            <div class="batch-detail-list" id="batchDetailList">
                                <!-- Se llenará dinámicamente -->
                            </div>
                        </div>
                        
                    </div>

                </div>
            </div>
        </div>
    </div>
    
    <!-- Modal para número de lote -->
    <div id="batchModal" class="batch-modal">
        <div class="batch-modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0;">📦 Crear Nuevo Lote</h3>
                <button onclick="closeBatchModal()" class="modal-close-btn" title="Cerrar">✕</button>
            </div>
            <p style="margin: 10px 0; color: #666;">
                Tienes <span id="modalSelectedCount">0</span> slabs seleccionados
            </p>
            <p style="margin: 15px 0 5px 0; font-weight: bold; color: #30336b;">Número de Lote:</p>
            <input type="number" id="modalBatchNumber" class="batch-modal-input" value="1" min="1">
            <div class="batch-modal-buttons">
                <button class="batch-modal-btn cancel" onclick="closeBatchModal()">
                    ❌ Cancelar
                </button>
                <button class="batch-modal-btn confirm" onclick="confirmBatchAssignment()">
                    ✅ Crear Lote
                </button>
            </div>
        </div>
    </div>

    <!-- Modal para alertas de lotes duplicados -->
    <div id="duplicadoModal" class="batch-modal" style="display: none;">
        <div class="batch-modal-content" style="width: 500px; max-width: 90%; padding: 25px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0; color: #e74c3c;">⚠️ Lote Duplicado Detectado</h3>
                <button onclick="cerrarModalDuplicado()" class="modal-close-btn" title="Cerrar">✕</button>
            </div>
            
            <div id="duplicadoInfo" style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <p style="margin: 0 0 10px 0; font-weight: bold; color: #856404;">📋 Información del Lote Existente:</p>
                <div id="duplicadoDetalles" style="font-size: 14px; color: #856404;">
                    <!-- Se llenará dinámicamente -->
                </div>
            </div>
            
            <p style="text-align: center; margin: 15px 0; color: #666; font-size: 14px;">
                El sistema creará una nueva entrada separada con el mismo número de lote.
            </p>
            
            <div style="text-align: center; margin-top: 20px;">
                <button id="duplicadoOkBtn" class="batch-modal-btn confirm" style="padding: 12px 30px; font-size: 16px;">
                    ✅ Entendido, Continuar
                </button>
            </div>
        </div>
    </div>

    <!-- Modal para tabla histórica -->
    <div id="tablaHistoricaModal" class="batch-modal" style="display: none;">
        <div id="tablaHistoricaContent" class="batch-modal-content movable-modal" style="width: 85%; max-width: 1200px; padding: 0; position: relative; max-height: 90vh; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
            <!-- Barra de título -->
            <div id="tablaHistoricaHeader" style="background: #1947BA; color: white; padding: 15px 20px; border-radius: 10px 10px 0 0; user-select: none; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h3 style="margin: 0; font-size: 16px;">📊 Histórico de Lotes</h3>
                    <p style="margin: 0; font-size: 11px; opacity: 0.9;">💡 Presiona ESC para cerrar</p>
                </div>
                <button onclick="cerrarTablaHistorica()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 14px;" title="Cerrar (ESC)">❌</button>
            </div>
            
            <!-- Contenido del modal -->
            <div style="padding: 20px; max-height: calc(90vh - 80px); overflow-y: auto;">
                <p style="text-align: center; font-size: 11px; color: #666; margin-bottom: 15px;">
                    📊 <strong>Histórico:</strong> Datos de solo lectura - No editable
                </p>
            
            <!-- Filtros -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd;">
                <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">🔍 Filtros</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr auto; gap: 10px; align-items: end;">
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Imagen:</label>
                        <input type="text" id="filtroImagen" placeholder="Filtrar por imagen..." 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Número de Lote:</label>
                        <input type="text" id="filtroLote" placeholder="Ej: 777" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Fecha Desde:</label>
                        <input type="date" id="filtroFechaDesde" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 3px;">Fecha Hasta:</label>
                        <input type="date" id="filtroFechaHasta" 
                               style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <button onclick="limpiarFiltrosHistorico()" 
                                style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; font-size: 12px; cursor: pointer;">
                            🗑️ Limpiar
                        </button>
                    </div>
                </div>
            </div>
            
            <div id="tablaHistoricaContainer" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <table id="tablaHistorica" style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead style="background: #f8f9fa; position: sticky; top: 0;">
                        <tr>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Fecha</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Imagen</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Lote</th>
                            <th style="padding: 10px; border: 1px solid #ddd; text-align: center;">Slabs</th>
                        </tr>
                    </thead>
                    <tbody id="tablaHistoricaBody">
                        <!-- Se llenará dinámicamente -->
                    </tbody>
                </table>
                <div id="contadorRegistros" style="text-align: center; padding: 10px; font-size: 12px; color: #666; border-top: 1px solid #ddd;">
                    <!-- Se mostrará el conteo de registros filtrados -->
                </div>
            </div>
            
                <div style="text-align: center; display: flex; gap: 15px; justify-content: center; margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee;">
                    <button class="batch-modal-btn" onclick="descargarCSVHistorico()" style="background: #008759; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                        📄 Descargar CSV
                    </button>
                    <button class="batch-modal-btn cancel" onclick="cerrarTablaHistorica()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                        🚪 Cerrar
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para limpiar base de datos -->
    <div id="cleanDatabaseModal" class="batch-modal" style="display: none;">
        <div class="batch-modal-content wide" style="padding: 25px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h3 style="margin: 0; color: #dc3545;">🗑️ Limpiar Base de Datos</h3>
                <button onclick="closeCleanDatabaseModal()" class="modal-close-btn" title="Cerrar">✕</button>
            </div>
            
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <p style="margin: 0 0 10px 0; font-weight: bold; color: #856404;">⚠️ ADVERTENCIA:</p>
                <p style="margin: 0; font-size: 14px; color: #856404;">
                    Esta acción eliminará permanentemente los datos seleccionados. 
                    Se recomienda crear un respaldo antes de continuar.
                </p>
            </div>
            
            <div style="margin: 20px 0;">
                <h4 style="margin: 0 0 15px 0; color: #333;">Opciones de Limpieza:</h4>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer; padding: 8px; border-radius: 4px; background: #f8f9fa;">
                        <input type="radio" name="cleanOption" value="json_cleanup" checked style="margin-right: 10px;">
                        <div>
                            <strong>📄 Limpieza JSON</strong>
                            <div style="font-size: 12px; color: #666;">Eliminar solo datos de persistencia JSON</div>
                        </div>
                    </label>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer; padding: 8px; border-radius: 4px; background: #f8f9fa;">
                        <input type="radio" name="cleanOption" value="csv_cleanup" style="margin-right: 10px;">
                        <div>
                            <strong>📊 Limpieza CSV</strong>
                            <div style="font-size: 12px; color: #666;">Eliminar solo base de datos histórica CSV</div>
                        </div>
                    </label>
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer; padding: 8px; border-radius: 4px; background: #f8f9fa;">
                        <input type="radio" name="cleanOption" value="images_cleanup" style="margin-right: 10px;">
                        <div>
                            <strong>🖼️ Limpieza Imágenes</strong>
                            <div style="font-size: 12px; color: #666;">Eliminar solo archivos de imágenes subidas</div>
                        </div>
                    </label>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; cursor: pointer; padding: 8px; border-radius: 4px; background: #f8f9fa;">
                        <input type="radio" name="cleanOption" value="total_cleanup" style="margin-right: 10px;">
                        <div>
                            <strong>💥 Limpieza Total</strong>
                            <div style="font-size: 12px; color: #666;">Eliminar JSON + CSV + Imágenes (reseteo completo)</div>
                        </div>
                    </label>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="createBackupCheck" checked style="margin-right: 10px;">
                        <span style="font-size: 14px;">💾 Crear respaldo automático antes de limpiar</span>
                    </label>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="batch-modal-btn cancel" onclick="closeCleanDatabaseModal()" style="margin-right: 15px;">
                    ❌ Cancelar
                </button>
                <button class="batch-modal-btn confirm" onclick="confirmCleanDatabase()" style="background: #dc3545;">
                    🗑️ Confirmar Limpieza
                </button>
            </div>
        </div>
    </div>

    <script>
        // ===== FUNCIÓN DE TOGGLE DE TEMA =====
        
        function toggleTheme() {
            const body = document.body;
            const themeBtn = document.querySelector('.theme-toggle');
            
            if (body.classList.contains('light-theme')) {
                body.classList.remove('light-theme');
                themeBtn.textContent = '🌙';
                localStorage.setItem('theme', 'dark');
            } else {
                body.classList.add('light-theme');
                themeBtn.textContent = '☀️';
                localStorage.setItem('theme', 'light');
            }
        }

        // Restaurar tema guardado al cargar la página
        window.addEventListener('DOMContentLoaded', function() {
            const savedTheme = localStorage.getItem('theme');
            const body = document.body;
            const themeBtn = document.querySelector('.theme-toggle');
            
            if (savedTheme === 'light') {
                body.classList.add('light-theme');
                themeBtn.textContent = '☀️';
            } else {
                body.classList.remove('light-theme');
                themeBtn.textContent = '🌙';
            }
        });
        
        // ===== SISTEMA DE MÚLTIPLES IMÁGENES =====
        
        // Sistema de múltiples imágenes
        let uploadedImages = []; // Array de todas las imágenes cargadas
        let currentActiveImage = null; // Imagen actualmente seleccionada
        let nextImageId = 1;
        
        // Sistema de persistencia
        let persistentData = null;
        
        // Variable para recordar último número de lote ingresado
        let lastBatchNumber = 0;
        
        // Variables por imagen (se almacenan en uploadedImages)
        let currentFile = null;
        let manualPoints = [];
        let isEditMode = false;
        let nextPointId = 1;
        let imageScale = 1;
        let imageTranslateX = 0;
        let imageTranslateY = 0;
        let originalImageSrc = null;
        let isUpdatingPoints = false;
        
        // Estado del preview (toggle entre original y detecciones)
        let isPreviewMode = false; // false = con detecciones, true = solo imagen original
        
        // Nuevas variables para modo de selección de lotes
        let editModeType = 'batches'; // 'slabs' o 'batches' - batches por defecto
        let isDrawing = false;
        let selectionPath = []; // Para selección libre
        let selectedSlabs = [];
        let nextBatchNumber = 1;
        let batches = []; // Almacenamiento de lotes
        let currentImageName = ''; // Nombre de la imagen actual
        
        // COLORES PARA LOTES
        const batchColors = [
            '#7FBC03', // Verde principal AZA
            '#1947BA', // Azul principal AZA
            '#008759', // Verde oscuro AZA
            '#046648', // Verde muy oscuro AZA
            '#CCE29E', // Verde claro AZA
            '#174DFA', // Azul vibrante AZA
            '#999DA0', // Gris neutro AZA
            '#393D47', // Gris oscuro AZA
            '#438DC3', // Azul claro AZA
            '#A8D8EA'  // Azul muy claro AZA
        ];
        
        function getBatchColor(batchNumber) {
            return batchColors[(batchNumber - 1) % batchColors.length];
        }

        // ===== FUNCIÓN DE SUBIDA CON BARRA DE PROGRESO =====
        
        function uploadFileWithProgress(formData, progressCallback) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                
                // Configurar evento de progreso
                xhr.upload.addEventListener('progress', (event) => {
                    if (event.lengthComputable) {
                        const percentComplete = (event.loaded / event.total) * 100;
                        progressCallback(percentComplete);
                    }
                });
                
                // Configurar respuesta
                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            resolve(response);
                        } catch (error) {
                            reject(error);
                        }
                    } else {
                        reject(new Error(`HTTP ${xhr.status}`));
                    }
                });
                
                xhr.addEventListener('error', () => {
                    reject(new Error('Error de red'));
                });
                
                // Enviar petición
                xhr.open('POST', '/upload');
                xhr.send(formData);
            });
        }
        
        // Variables globales para seguimiento de progreso
        let globalUploadProgress = {
            currentFile: 0,
            totalFiles: 0,
            overallProgress: 0
        };
        
        function updateGlobalProgress(fileProgress, fileIndex, totalFiles, fileName) {
            const progressContainer = document.getElementById('uploadProgress');
            const progressBar = document.getElementById('uploadProgressBar');
            const progressPercent = document.getElementById('uploadProgressPercent');
            const progressText = document.getElementById('uploadProgressText');
            
            // Mostrar contenedor si está oculto
            if (progressContainer.style.display === 'none' || !progressContainer.style.display.length) {
                progressContainer.style.display = 'block';
            }
            
            // Calcular progreso general
            const baseProgress = (fileIndex / totalFiles) * 100;
            const currentFileProgress = (fileProgress / totalFiles);
            const overallProgress = Math.min(100, baseProgress + currentFileProgress);
            
            // Actualizar elementos visuales
            progressBar.style.width = overallProgress + '%';
            progressPercent.textContent = Math.round(overallProgress) + '%';
            
            // Texto removido del interior de la barra
            
            // Ocultar cuando termine completamente
            if (overallProgress >= 100) {
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 1000);
            }
        }
        
        // ===== FUNCIONES DE PERSISTENCIA OPTIMIZADAS =====

        async function optimizePersistentData() {
            // Optimiza el archivo de persistencia eliminando datos pesados
            try {
                const response = await fetch('/optimize_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('🔧 PERSISTENCIA OPTIMIZADA exitosamente');
                    return true;
                } else {
                    console.log('⚠️ Error optimizando persistencia:', result.error);
                    return false;
                }
            } catch (error) {
                console.log('⚠️ Error optimizando persistencia:', error);
                return false;
            }
        }

        async function loadPersistentData() {
            // Carga datos persistentes al inicializar la aplicación
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // Timeout de 5 segundos
                
                const response = await fetch('/load_persistent_data', {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    persistentData = result.data;
                    console.log(`📦 Datos persistentes cargados: ${persistentData.images.length} imágenes`);
                    return persistentData;
                } else {
                    console.log('📁 No hay datos persistentes previos');
                    return null;
                }
            } catch (error) {
                console.log('⚠️ Error o timeout cargando datos persistentes:', error.message);
                return null;
            }
        }

        async function saveImageDataToPersistence(imageData) {
            // Guarda datos de imagen en persistencia (no bloqueante)
            console.log(`💾 saveImageDataToPersistence iniciado para: ${imageData.name}`);
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log(`⏰ Timeout de 5s alcanzado para ${imageData.name}`);
                    controller.abort();
                }, 5000); // Timeout de 5 segundos
                
                const response = await fetch('/save_image_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        imageData: {
                            name: imageData.name,
                            status: imageData.status,
                            manualPoints: imageData.manualPoints || [],
                            batches: imageData.batches || [],
                            nextPointId: imageData.nextPointId || 1,
                            // Solo enviar resumen de detección, NO datos completos pesados
                            detectionData: imageData.detectionData ? {
                                count: imageData.detectionData.count || 0,
                                fromPersistence: imageData.detectionData.fromPersistence || false
                            } : null,
                            createdAt: imageData.createdAt,
                            updatedAt: new Date().toISOString()
                        }
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log(`💾 Respuesta del servidor para ${imageData.name}:`, result);
                
                if (result.success) {
                    console.log(`✅ saveImageDataToPersistence exitoso para: ${imageData.name}`);
                    return true;
                } else {
                    console.log(`❌ saveImageDataToPersistence falló para ${imageData.name}:`, result.error);
                    return false;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log(`⏰ Timeout guardando datos para ${imageData.name}`);
                } else {
                    console.log(`❌ Error de red guardando ${imageData.name}:`, error.message);
                }
                return false; // No bloquear si hay error
            }
        }

        async function loadImageDataFromPersistence(filename) {
            // Carga datos de imagen específica desde persistencia
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // Timeout de 5 segundos
                
                const response = await fetch(`/get_image_data/${encodeURIComponent(filename)}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    console.log(`📂 Datos cargados para: ${filename}`);
                    return result.data;
                } else {
                    console.log(`📁 No hay datos persistentes para: ${filename}`);
                    return null;
                }
            } catch (error) {
                console.log(`⚠️ Error o timeout cargando datos para ${filename}:`, error.message);
                return null; // No bloquear si hay error
            }
        }


        // Configurar slider
        const confidenceSlider = document.getElementById('confidenceSlider');
        const confidenceInput = document.getElementById('confidenceInput');
        
        // Función para sincronizar valores bidireccional
        function updateConfidenceValues(value) {
            const numValue = parseFloat(value);
            const clampedValue = Math.max(0.1, Math.min(1.0, numValue));
            const formattedValue = clampedValue.toFixed(2);
            
            confidenceSlider.value = formattedValue;
            confidenceInput.value = formattedValue;
        }
        
        // Event listener para el slider
        confidenceSlider.addEventListener('input', function() {
            updateConfidenceValues(this.value);
        });
        
        // Event listener para el input numérico
        confidenceInput.addEventListener('input', function() {
            updateConfidenceValues(this.value);
        });

        // Configurar drag & drop
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleMultipleFiles(Array.from(files));
            }
        });

        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                handleMultipleFiles(Array.from(this.files));
            }
        });

        function handleMultipleFiles(files) {
            if (files.length === 0) return;
            
            // Filtrar archivos duplicados
            const existingNames = uploadedImages.map(img => img.name);
            const newFiles = files.filter(file => {
                if (existingNames.includes(file.name)) {
                    showAlert(`Imagen ya cargada: ${file.name}`, 'error');
                    return false;
                }
                return true;
            });
            
            if (newFiles.length === 0) {
                document.getElementById('uploadStatus').textContent = 'Todas las imágenes ya están cargadas';
                return;
            }
            
            document.getElementById('uploadStatus').textContent = `Procesando ${newFiles.length} archivo(s) nuevo(s)...`;
            let successCount = 0;
            let errorCount = 0;
            
            // Inicializar progreso global
            globalUploadProgress.totalFiles = newFiles.length;
            globalUploadProgress.currentFile = 0;
            
            newFiles.forEach((file, index) => {
                setTimeout(() => {
                    handleSingleFile(file, index).then(success => {
                        if (success) successCount++;
                        else errorCount++;
                        
                        console.log(`📊 Progreso: ${successCount} exitosas, ${errorCount} errores de ${newFiles.length} total`);
                        
                        // Actualizar estado cuando termine el último archivo
                        if (successCount + errorCount === newFiles.length) {
                            const statusMsg = `✅ ${successCount} imagen(es) cargada(s)` + 
                                            (errorCount > 0 ? ` | ❌ ${errorCount} error(es)` : '');
                            document.getElementById('uploadStatus').textContent = statusMsg;
                            updateImagesGrid();
                            
                            // Actualizar navegación entre imágenes
                            updateImageNavigation();
                            
                            // Auto-seleccionar la primera imagen si no hay ninguna activa
                            // DELAY para permitir que la restauración de datos termine COMPLETAMENTE
                            if (!currentActiveImage && uploadedImages.length > 0) {
                                setTimeout(() => {
                                    selectImage(uploadedImages[0].id);
                                }, 500); // Medio segundo de delay
                            }
                        }
                    });
                }, index * 200); // Delay para evitar sobrecarga
            });
        }
        
        function handleSingleFile(file, fileIndex = 0) {
            return new Promise((resolve) => {
                // Validar archivo
                const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/bmp', 'image/tiff', 'image/webp'];
                if (!allowedTypes.includes(file.type)) {
                    showAlert(`Tipo no permitido: ${file.name}`, 'error');
                    resolve(false);
                    return;
                }

                if (file.size > 16 * 1024 * 1024) {
                    showAlert(`Archivo muy grande: ${file.name}`, 'error');
                    resolve(false);
                    return;
                }

                // Crear objeto imagen
                const imageObj = {
                    id: nextImageId++,
                    name: file.name,
                    file: file,
                    status: 'uploading',
                    uploadData: null,
                    detectionData: null,
                    manualPoints: [],
                    batches: [],
                    nextPointId: 1,
                    originalImageSrc: null,
                    createdAt: new Date().toISOString()
                };

                // Agregar a la lista
                uploadedImages.push(imageObj);

                // Subir archivo
                const formData = new FormData();
                formData.append('file', file);

                uploadFileWithProgress(formData, (progress) => {
                    updateGlobalProgress(progress, fileIndex, globalUploadProgress.totalFiles, file.name);
                })
.then(data => {
                    if (data.success) {
                        imageObj.status = 'uploaded';
                        imageObj.uploadData = data;
                        console.log(`✅ Subida exitosa: ${file.name}`);
                        
                        // Generar preview y cargar datos persistentes
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            imageObj.originalImageSrc = e.target.result;
                            
                            // CARGAR DATOS PERSISTENTES DE FORMA ROBUSTA
                            loadImageDataFromPersistence(file.name)
                                .then(persistedData => {
                                    if (persistedData) {
                                        console.log(`📂 DATOS ENCONTRADOS para ${file.name}:`, persistedData);
                                        
                                        // Restaurar datos persistentes OPTIMIZADOS
                                        imageObj.manualPoints = persistedData.manualPoints || [];
                                        imageObj.batches = persistedData.batches || [];
                                        imageObj.nextPointId = persistedData.nextPointId || 1;
                                        
                                        // Usar detectionSummary en lugar de detectionData completo
                                        if (persistedData.detectionSummary) {
                                            imageObj.detectionData = {
                                                success: true,
                                                count: persistedData.detectionSummary.count,
                                                fromPersistence: true  // Marcar que viene de persistencia
                                            };
                                        } else {
                                            imageObj.detectionData = null;
                                        }
                                        
                                        // Determinar estado correcto
                                        if (persistedData.batches && persistedData.batches.length > 0) {
                                            imageObj.status = 'with-batches';
                                            console.log(`🔄 IMAGEN RESTAURADA: ${file.name} - ${imageObj.manualPoints.length} slabs, ${imageObj.batches.length} lotes`);
                                        } else if (persistedData.detectionData) {
                                            imageObj.status = 'detected';
                                            console.log(`🔄 IMAGEN DETECTADA RESTAURADA: ${file.name} - ${imageObj.manualPoints.length} slabs`);
                                        }
                                        
                                        // Actualizar UI inmediatamente
                                        updateImagesGrid();
                                        
                                        // Si es la imagen activa, actualizar la vista
                                        if (currentActiveImage && currentActiveImage.id === imageObj.id) {
                                            updateActiveImageInfo();
                                        }
                                        
                                        console.log(`✅ PERSISTENCIA RESTAURADA para: ${file.name}`);
                                    } else {
                                        console.log(`📁 No hay datos persistentes para: ${file.name}`);
                                    }
                                })
                                .catch(error => {
                                    console.log(`⚠️ Error cargando persistencia para ${file.name}:`, error);
                                })
                                .finally(() => {
                                    // Actualizar UI al final
                                    updateImagesGrid();
                                });
                            
                            resolve(true);
                        };
                        reader.readAsDataURL(file);
                    } else {
                        imageObj.status = 'error';
                        resolve(false);
                    }
                })
                .catch(error => {
                    console.error('❌ Error subiendo:', file.name, error);
                    imageObj.status = 'error';
                    showAlert(`Error subiendo ${file.name}: ${error.message}`, 'error');
                    resolve(false);
                });
            });
        }
        
        function updateImagesGrid(filteredImages = null) {
            const grid = document.getElementById('imagesGrid');
            const totalCount = document.getElementById('totalImagesCount');
            const filterStatus = document.getElementById('statusFilter').value;
            
            // Si no se proporcionan imágenes filtradas, aplicar el filtro actual
            let imagesToShow;
            if (filteredImages !== null) {
                imagesToShow = filteredImages;
            } else if (filterStatus !== 'all') {
                // Aplicar filtro automáticamente
                imagesToShow = uploadedImages.filter(img => {
                    switch (filterStatus) {
                        case 'uploaded':
                            return img.status === 'uploaded' && (!img.batches || img.batches.length === 0) && !img.detectionData;
                        case 'detected':
                            return img.status === 'detected' || (img.detectionData && (!img.batches || img.batches.length === 0));
                        case 'with_batches':
                            return img.batches && img.batches.length > 0;
                        default:
                            return true;
                    }
                });
            } else {
                imagesToShow = uploadedImages;
            }
            
            // Debug log para rastrear estados
            if (imagesToShow.length === 1) {
                const img = imagesToShow[0];
                console.log(`🔍 DEBUG imagen única: ${img.name}`);
                console.log(`   - Status: ${img.status}`);
                console.log(`   - Batches: ${img.batches ? img.batches.length : 0}`);
                console.log(`   - ManualPoints: ${img.manualPoints ? img.manualPoints.length : 0}`);
                console.log(`   - DetectionData: ${img.detectionData ? 'Sí' : 'No'}`);
            }
            
            // Actualizar contador
            if (filterStatus === 'all') {
                totalCount.textContent = `Total: ${uploadedImages.length} imágenes`;
            } else {
                totalCount.textContent = `Mostrando: ${imagesToShow.length} de ${uploadedImages.length} imágenes`;
            }
            
            if (imagesToShow.length === 0) {
                const noResultsMessage = filterStatus === 'all' ? 
                    'No hay imágenes<br><small>Sube desde panel izquierdo</small>' :
                    'No hay imágenes con este estado<br><small>Prueba otro filtro</small>';
                    
                grid.innerHTML = `
                    <div class="no-images-message">
                        <p style="text-align: center; color: #999; padding: 20px; font-size: 12px;">
                            📷 ${noResultsMessage}
                        </p>
                    </div>
                `;
                return;
            }
            
            const cardsHtml = imagesToShow.map(img => {
                // Debug para imagen única - RASTREAR EL PROBLEMA
                if (imagesToShow.length === 1) {
                    console.log(`🔥 ACTUALIZANDO GRID - IMAGEN ÚNICA: ${img.name}`);
                    console.log(`   - Status interno: '${img.status}'`);
                    console.log(`   - Batches: ${img.batches?.length || 0}`);
                    console.log(`   - ManualPoints: ${img.manualPoints?.length || 0}`);
                    console.log(`   - DetectionData: ${img.detectionData ? 'Sí' : 'No'}`);
                }
                
                // Determinar estado más preciso y robusto
                let statusClass, statusText;
                
                // 1. Prioridad máxima: si tiene lotes definidos
                if (img.batches && img.batches.length > 0) {
                    statusClass = 'with-batches';
                    statusText = 'Con Lotes';
                // 2. Si tiene puntos manuales o datos de detección
                } else if (img.manualPoints && img.manualPoints.length > 0) {
                    statusClass = 'detected';
                    statusText = 'Detectado';
                // 3. Si tiene datos de detección (incluso sin puntos)
                } else if (img.detectionData && img.detectionData.count > 0) {
                    statusClass = 'detected';
                    statusText = 'Detectado';
                // 4. Estados específicos del flujo
                } else if (img.status === 'editing') {
                    statusClass = 'editing';
                    statusText = 'Editando';
                } else if (img.status === 'with-batches') {
                    statusClass = 'with-batches';
                    statusText = 'Con Lotes';
                } else if (img.status === 'detected') {
                    statusClass = 'detected';
                    statusText = 'Detectado';
                } else if (img.status === 'uploaded') {
                    statusClass = 'uploaded';
                    statusText = 'Cargado';
                // 5. Por defecto: cargado (NO "procesando")
                } else {
                    statusClass = 'uploaded';
                    statusText = 'Cargado';
                }
                
                // Debug final para imagen única
                if (imagesToShow.length === 1) {
                    console.log(`🎯 ESTADO FINAL DETERMINADO: ${statusText} (${statusClass})`);
                }
                
                const activeClass = currentActiveImage && currentActiveImage.id === img.id ? 'active' : '';
                
                return `
                    <div class="image-card ${activeClass}" data-image-id="${img.id}" onclick="selectImage(${img.id})">
                        <div class="image-card-buttons">
                            <button class="clean-data-btn" onclick="cleanImageData(${img.id}); event.stopPropagation();" title="Limpiar datos de persistencia">🗑️</button>
                            <button class="delete-btn" onclick="deleteImage(${img.id}); event.stopPropagation();" title="Eliminar imagen">✖</button>
                        </div>
                        <div class="image-card-content">
                            <div class="image-name" title="${img.name}">${img.name}</div>
                            <div class="image-status ${statusClass}">${statusText}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            grid.innerHTML = cardsHtml;
            
            // Actualizar navegación entre imágenes
            updateImageNavigation();
        }
        
        function filterImagesByStatus() {
            // Simplemente actualizar el grid, que ahora detecta automáticamente el filtro
            updateImagesGrid();
        }
        
        function clearAllVisualElements() {
            // Limpiar completamente todos los elementos visuales
            hideResults();
            hidePreview();
            clearSelection();
            hideFreeSelection();
            resetImageTransform();
            
            // Limpiar contenedores de imagen
            const previewContainer = document.getElementById('previewContainer');
            const imageContainer = document.getElementById('imageContainer');
            if (previewContainer) previewContainer.innerHTML = '';
            if (imageContainer) imageContainer.innerHTML = '';
            
            // Limpiar overlays SVG si existen
            const svgOverlays = document.querySelectorAll('svg');
            svgOverlays.forEach(svg => {
                if (svg.classList.contains('point-overlay') || svg.classList.contains('selection-overlay')) {
                    svg.remove();
                }
            });
            
            // Limpiar puntos y elementos dinámicos
            const dynamicPoints = document.querySelectorAll('.point, .manual-point, .selection-rect');
            dynamicPoints.forEach(point => point.remove());
            
            // Resetear variables de selección
            selectedSlabs = [];
            isEditMode = false;
            editModeType = 'slabs';
        }
        
        // Lógica simplificada - solo necesitamos saber si la imagen actual tiene cambios
        
        // Variable simple para rastrear si la imagen actual tiene cambios
        let currentImageHasChanges = false;
        // Variable para evitar marcar cambios durante la carga inicial
        let isLoadingImage = false;
        
        // Marcar que la imagen actual tiene cambios
        function markCurrentImageAsChanged() {
            if (currentActiveImage && !isLoadingImage) {
                currentImageHasChanges = true;
                console.log(`🔄 Imagen ${currentActiveImage.name} marcada como modificada`);
                updateSaveStatusIndicator();
            } else if (isLoadingImage) {
                console.log('💼 Cambios ignorados durante carga de imagen');
            } else {
                console.log('⚠️ Intento de marcar cambios sin imagen activa - IGNORADO');
            }
        }
        
        // Marcar que la imagen actual está guardada
        function markCurrentImageAsSaved() {
            if (currentActiveImage) {
                currentImageHasChanges = false;
                console.log(`✅ Imagen ${currentActiveImage.name} marcada como guardada`);
                updateSaveStatusIndicator(); // Actualizar indicador inmediatamente
            }
        }
        
        // Función para verificar si hay trabajo (para el auto-guardado)
        function hasUnsavedWork() {
            if (!currentActiveImage) return false;
            
            const hasManualPoints = manualPoints && manualPoints.length > 0;
            const hasBatches = batches && batches.length > 0;
            return hasManualPoints || hasBatches;
        }
        
        // Modal eliminado - auto-guardado automático sin intervención del usuario

        async function selectImage(imageId, isNavigation = false) {
            // AUTO-GUARDAR la imagen actual antes de cambiar (SOLO si tiene datos significativos)
            if (currentActiveImage && hasSignificantData(currentActiveImage)) {
                if (isNavigation) {
                    console.log('⏭️ Navegación: Guardando estado actual sin incrementar contador...');
                    // Guardar sin marcar como cambio (para navegación)
                    await saveCurrentImageDataSilently();
                } else {
                    console.log('💾 Auto-guardando imagen actual antes de cambiar...');
                    await saveCurrentImageData();
                }
            } else if (currentActiveImage) {
                console.log(`🚫 NO GUARDANDO ${currentActiveImage.name} - No hay datos significativos`);
            }
            
            // MARCAR QUE ESTAMOS CARGANDO IMAGEN (evitar marcar cambios falsos)
            isLoadingImage = true;
            
            // CRITICAL: Limpiar completamente todos los elementos visuales de la imagen anterior
            clearAllVisualElements();
            
            // Cargar nueva imagen
            const imageObj = uploadedImages.find(img => img.id === imageId);
            if (!imageObj) {
                isLoadingImage = false;
                return;
            }
            
            currentActiveImage = imageObj;
            
            // Restaurar variables globales CON DATOS PERSISTENTES
            currentFile = imageObj.uploadData;
            manualPoints = [...(imageObj.manualPoints || [])];
            batches = [...(imageObj.batches || [])];
            nextPointId = imageObj.nextPointId || 1;
            originalImageSrc = imageObj.originalImageSrc;
            currentImageName = imageObj.name;
            
            // Nueva imagen = sin cambios inicialmente
            currentImageHasChanges = false;
            
            // Actualizar indicador inmediatamente para nueva imagen
            updateSaveStatusIndicator();
            
            // Si la imagen tiene trabajo, actualizar timestamp de guardado
            if (manualPoints.length > 0 || batches.length > 0) {
                lastAutoSaveTime = Date.now();
                console.log(`💾 Imagen cargada con trabajo existente, timestamp actualizado`);
                updateSaveStatusIndicator();
            }
            
            console.log(`🔄 SELECCIONANDO IMAGEN: ${imageObj.name}`);
            console.log(`   📊 Manual Points: ${manualPoints.length}`);
            console.log(`   📦 Batches: ${batches.length}`);
            console.log(`   🎯 Status: ${imageObj.status}`);
            
            // Actualizar interfaz del panel central
            document.getElementById('activeImageTitle').textContent = imageObj.name;
            document.getElementById('noActiveImage').style.display = 'none';
            
            // Mostrar preview
            if (imageObj.originalImageSrc) {
                showPreviewForImage(imageObj);
            }
            
            // Habilitar detección si está cargada
            document.getElementById('detectBtn').disabled = !imageObj.uploadData;
            
            // Si ya tiene detección O datos persistentes, mostrar resultados
            if (imageObj.detectionData || (imageObj.manualPoints && imageObj.manualPoints.length > 0)) {
                console.log(`🎯 Mostrando resultados porque tiene datos: detectionData=${!!imageObj.detectionData}, manualPoints=${imageObj.manualPoints?.length || 0}`);
                showResultsForImage(imageObj);
            } else {
                console.log(`📁 No hay datos para mostrar, ocultando resultados`);
                hideResults();
            }
            
            // PRESERVAR estado ya establecido correctamente
            console.log(`🔍 ANTES de updateImagesGrid en selectImage: ${imageObj.name} tiene estado '${imageObj.status}'`);
            console.log(`   - Batches: ${imageObj.batches?.length || 0}`);
            console.log(`   - ManualPoints: ${imageObj.manualPoints?.length || 0}`);
            
            // Solo actualizar grid si el estado no está ya correctamente establecido
            // Evitar sobrescribir "with-batches" con "procesando"
            const shouldUpdateGrid = !(
                imageObj.status === 'with-batches' && 
                imageObj.batches && 
                imageObj.batches.length > 0
            );
            
            if (shouldUpdateGrid) {
                console.log(`🔄 Actualizando grid para ${imageObj.name}`);
                updateImagesGrid();
            } else {
                console.log(`🚫 NO actualizando grid para ${imageObj.name} - estado ya correcto: ${imageObj.status}`);
            }
            
            updateActiveImageInfo();
            
            // Inicializar estado del botón preview
            isPreviewMode = false; // Siempre inicia mostrando detecciones
            updatePreviewButtonText();
            
            // FINALIZAR CARGA (permitir marcar cambios de nuevo)
            setTimeout(() => {
                isLoadingImage = false;
                // Solo resetear el estado de cambios si NO estamos navegando con cambios pendientes
                if (!isNavigation) {
                    currentImageHasChanges = false; // Resetear estado de cambios para nueva imagen seleccionada manualmente
                    console.log('✅ Carga de imagen completada - Estado de cambios reseteado');
                } else {
                    console.log('✅ Carga de imagen completada - Estado de cambios preservado (navegación)');
                }
            }, 500); // Dar tiempo a que terminen todos los setTimeout internos
            
            // Actualizar navegación entre imágenes
            updateImageNavigation();
            
            console.log(`Imagen seleccionada: ${imageObj.name}`);
        }
        
        // ===== SISTEMA DE AUTO-GUARDADO ROBUSTO =====
        
        let saveTimeout = null;
        
        function autoSaveCurrentImageData() {
            // SOLO marcar cambios si realmente hay imagen activa
            if (currentActiveImage) {
                markCurrentImageAsChanged();
            }
            
            // Auto-guardado con debounce para evitar spam
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            saveTimeout = setTimeout(() => {
                saveCurrentImageDataNow();
            }, 500); // Espera 500ms después del último cambio
        }
        
        async function saveCurrentImageDataNow() {
            if (!currentActiveImage) {
                console.log('⚠️ No hay imagen activa para guardar');
                return;
            }
            
            // PREVENIR GUARDADO INNECESARIO: Solo guardar si hay datos significativos
            if (!hasSignificantData(currentActiveImage)) {
                console.log(`🚫 GUARDADO CANCELADO para ${currentActiveImage.name} - No hay datos significativos`);
                return;
            }
            
            // Actualizar datos en el objeto imagen
            currentActiveImage.manualPoints = [...manualPoints];
            currentActiveImage.batches = [...batches];
            currentActiveImage.nextPointId = nextPointId;
            currentActiveImage.updatedAt = new Date().toISOString();
            
            console.log(`💾 AUTO-GUARDANDO DATOS para ${currentActiveImage.name}:`);
            console.log(`   📊 Manual Points: ${currentActiveImage.manualPoints.length}`);
            console.log(`   📦 Batches: ${currentActiveImage.batches.length}`);
            console.log(`   🕒 Timestamp: ${currentActiveImage.updatedAt}`);
            
            // GUARDAR CON VALIDACIÓN MEJORADA
            try {
                const result = await saveImageDataWithValidation(currentActiveImage);
                
                if (result.success) {
                    let message = `✅ AUTO-GUARDADO EXITOSO para: ${currentActiveImage.name}`;
                    if (result.verified) {
                        message += ' (verificado)';
                    } else if (result.retried) {
                        message += ' (segundo intento)';
                    }
                    console.log(message);
                    
                    // IMPORTANTE: Marcar como guardado exitoso PRIMERO
                    markSaveSuccess();
                    markCurrentImageAsSaved(); // Marcar imagen como guardada
                    
                    // NO CAMBIAR EL ESTADO AQUÍ - respetar el estado establecido por otras funciones
                    // El estado debe ser manejado por detectSlabs(), assignBatch(), etc.
                    
                    updateImagesGrid();
                    updateActiveImageInfo();
                } else {
                    console.log(`❌ ERROR EN AUTO-GUARDADO para: ${currentActiveImage.name} - ${result.error}`);
                    
                    // Como último recurso, intentar respaldo forzado (pero no bloquear UI)
                    console.log('🆘 Intentando respaldo forzado como último recurso...');
                    forceBackup().then(backupSuccess => {
                        if (backupSuccess) {
                            console.log('✅ Respaldo forzado exitoso como fallback');
                        } else {
                            console.log('❌ Respaldo forzado también falló');
                        }
                    });
                }
            } catch (error) {
                console.log(`❌ EXCEPCIÓN EN AUTO-GUARDADO:`, error);
            }
        }
        
        // Función de guardado síncrono para casos críticos
        async function saveCurrentImageData() {
            return await saveCurrentImageDataNow();
        }
        
        // Función para validar si hay datos significativos que justifiquen crear/actualizar un registro
        function hasSignificantData(imageObj = null) {
            const targetImage = imageObj || currentActiveImage;
            if (!targetImage) return false;
            
            // Solo considerar datos significativos si hay:
            // 1. Puntos manuales (detección o edición manual) - REQUISITO PRINCIPAL
            // 2. Lotes asignados - REQUISITO PRINCIPAL
            // 3. Estado 'with-batches' (significa que hay trabajo real completado)
            
            const hasManualPoints = targetImage.manualPoints && targetImage.manualPoints.length > 0;
            const hasBatches = targetImage.batches && targetImage.batches.length > 0;
            const hasBatchesState = targetImage.status === 'with-batches';
            
            // IMPORTANTE: Solo los puntos manuales y lotes son datos realmente significativos
            // El estado 'detected' por sí solo NO es suficiente para justificar persistencia
            const significant = hasManualPoints || hasBatches || hasBatchesState;
            
            if (!significant) {
                console.log(`🚫 NO HAY DATOS SIGNIFICATIVOS para ${targetImage.name} - Status: ${targetImage.status}, Points: ${targetImage.manualPoints?.length || 0}, Batches: ${targetImage.batches?.length || 0}`);
            } else {
                console.log(`✅ DATOS SIGNIFICATIVOS encontrados para ${targetImage.name} - Points: ${targetImage.manualPoints?.length || 0}, Batches: ${targetImage.batches?.length || 0}, Status: ${targetImage.status}`);
            }
            
            return significant;
        }
        
        // Función para guardar sin marcar como cambio (para navegación)
        async function saveCurrentImageDataSilently() {
            if (!currentActiveImage) {
                console.log('⚠️ No hay imagen activa para guardar silenciosamente');
                return;
            }
            
            // PREVENIR GUARDADO INNECESARIO: Solo guardar si hay datos significativos
            if (!hasSignificantData(currentActiveImage)) {
                console.log(`🚫 GUARDADO CANCELADO para ${currentActiveImage.name} - No hay datos significativos`);
                return;
            }
            
            // Actualizar datos en el objeto imagen SIN marcar como cambio
            currentActiveImage.manualPoints = [...manualPoints];
            currentActiveImage.batches = [...batches];
            currentActiveImage.nextPointId = nextPointId;
            currentActiveImage.updatedAt = new Date().toISOString();
            
            console.log(`🔇 GUARDADO SILENCIOSO para ${currentActiveImage.name} (navegación)`);
            
            try {
                const response = await fetch('/save_image_data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: currentActiveImage.name,
                        manualPoints: manualPoints,
                        batches: batches,
                        nextPointId: nextPointId,
                        status: currentActiveImage.status
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log(`✅ GUARDADO SILENCIOSO EXITOSO para: ${currentActiveImage.name}`);
                    // NO llamar markCurrentImageAsSaved() para evitar resetear el estado de cambios
                } else {
                    console.log(`❌ ERROR EN GUARDADO SILENCIOSO: ${result.error}`);
                }
            } catch (error) {
                console.log(`❌ EXCEPCIÓN EN GUARDADO SILENCIOSO:`, error);
            }
        }
        
        // Función para mostrar notificaciones al usuario
        function showNotification(message, type = 'info', duration = 3000) {
            // Crear elemento de notificación
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-message">${message}</span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;
            
            // Agregar estilos inline si no existen en CSS
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                min-width: 300px;
                max-width: 500px;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 30000;
                animation: slideInRight 0.3s ease-out;
                font-family: inherit;
                font-size: 14px;
            `;
            
            // Aplicar colores según el tipo
            switch(type) {
                case 'success':
                    notification.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                    notification.style.color = 'white';
                    break;
                case 'warning':
                    notification.style.background = 'linear-gradient(135deg, #fd7e14 0%, #ffc107 100%)';
                    notification.style.color = 'white';
                    break;
                case 'error':
                    notification.style.background = 'linear-gradient(135deg, #dc3545 0%, #e74c3c 100%)';
                    notification.style.color = 'white';
                    break;
                default:
                    notification.style.background = 'linear-gradient(135deg, #1947BA 0%, #4834D4 100%)';
                    notification.style.color = 'white';
            }
            
            // Estilos para el contenido
            const content = notification.querySelector('.notification-content');
            content.style.cssText = `
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 15px;
            `;
            
            // Estilos para el botón de cerrar
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.2);
                border: none;
                color: inherit;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                transition: background 0.2s ease;
            `;
            
            closeBtn.onmouseover = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
            closeBtn.onmouseout = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
            
            // Agregar animación CSS si no existe
            if (!document.querySelector('#notification-animations')) {
                const style = document.createElement('style');
                style.id = 'notification-animations';
                style.textContent = `
                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    @keyframes slideOutRight {
                        from {
                            transform: translateX(0);
                            opacity: 1;
                        }
                        to {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Agregar al DOM
            document.body.appendChild(notification);
            
            // Auto-remover después del duration especificado
            if (duration > 0) {
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.style.animation = 'slideOutRight 0.3s ease-out';
                        setTimeout(() => {
                            if (notification.parentElement) {
                                notification.remove();
                            }
                        }, 300);
                    }
                }, duration);
            }
            
            console.log(`📢 Notificación mostrada: ${message}`);
        }
        
        // Función para verificar el estado de guardado con el servidor
        async function verifySaveStatus(imageName, clientData) {
            try {
                const response = await fetch('/verify_save_status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image_name: imageName,
                        client_data: clientData
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                if (result.success) {
                    console.log(`🔍 Verificación de guardado para ${imageName}:`, result);
                    return result;
                } else {
                    console.log('⚠️ Error verificando estado:', result.error);
                    return null;
                }
            } catch (error) {
                console.log('⚠️ Error verificando estado de guardado:', error.message);
                return null;
            }
        }
        
        // Función para forzar respaldo completo
        async function forceBackup() {
            try {
                showNotification('💾 Creando respaldo completo...', 'info', 0); // Sin timeout
                
                const response = await fetch('/force_save_backup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                // Remover notificación de "creando respaldo"
                const existingNotifications = document.querySelectorAll('.notification');
                existingNotifications.forEach(n => n.remove());
                
                if (result.success) {
                    const info = result.backup_info;
                    
                    // IMPORTANTE: Actualizar timestamp tras respaldo exitoso
                    lastAutoSaveTime = Date.now();
                    updateSaveStatusIndicator();
                    
                    showNotification(
                        `✅ Respaldo completo exitoso: ${info.images_in_json} imágenes, ${info.records_in_csv} registros CSV`, 
                        'success', 
                        5000
                    );
                    console.log('💾 Respaldo forzado completado:', result);
                    return true;
                } else {
                    showNotification(`❌ Error en respaldo: ${result.error}`, 'error');
                    return false;
                }
            } catch (error) {
                // Remover notificación de "creando respaldo"
                const existingNotifications = document.querySelectorAll('.notification');
                existingNotifications.forEach(n => n.remove());
                
                showNotification(`❌ Error forzando respaldo: ${error.message}`, 'error');
                console.log('❌ Error forzando respaldo:', error);
                return false;
            }
        }
        
        // Función mejorada para guardar con validación
        async function saveImageDataWithValidation(imageData) {
            console.log(`🔍 Iniciando guardado con validación para: ${imageData.name}`);
            console.log(`   📊 Puntos: ${imageData.manualPoints ? imageData.manualPoints.length : 0}`);
            console.log(`   📦 Lotes: ${imageData.batches ? imageData.batches.length : 0}`);
            
            try {
                // 1. Validar datos antes de guardar
                if (!imageData || !imageData.name) {
                    throw new Error('Datos de imagen inválidos: falta nombre');
                }
                
                // 2. Intentar guardado normal
                console.log(`💾 Paso 1: Guardando en persistencia...`);
                const saveSuccess = await saveImageDataToPersistence(imageData);
                
                if (!saveSuccess) {
                    console.log(`❌ Paso 1 falló: saveImageDataToPersistence retornó false`);
                    throw new Error('Guardado inicial falló - saveImageDataToPersistence retornó false');
                }
                
                console.log(`✅ Paso 1 exitoso: Datos guardados en persistencia`);
                
                // 3. Verificar que se guardó correctamente
                console.log(`🔍 Paso 2: Verificando guardado...`);
                const verificationResult = await verifySaveStatus(imageData.name, {
                    manualPoints: imageData.manualPoints || [],
                    batches: imageData.batches || []
                });
                
                if (verificationResult === null) {
                    console.log(`⚠️ Paso 2: Verificación falló (timeout o error de red)`);
                    // Si la verificación falla por red, asumir que el guardado fue exitoso
                    return { success: true, verified: false, networkError: true };
                }
                
                if (verificationResult && verificationResult.saved) {
                    console.log(`✅ Paso 2 exitoso: Guardado verificado correctamente`);
                    return { success: true, verified: true };
                } else {
                    console.log(`⚠️ Paso 2: Guardado no verificado. Resultado:`, verificationResult);
                    
                    // 4. Intentar segundo guardado si la verificación falló
                    console.log(`🔄 Paso 3: Reintentando guardado...`);
                    const secondSave = await saveImageDataToPersistence(imageData);
                    if (secondSave) {
                        console.log(`✅ Paso 3 exitoso: Segundo guardado completado`);
                        return { success: true, verified: false, retried: true };
                    } else {
                        console.log(`❌ Paso 3 falló: Segundo guardado también falló`);
                        throw new Error('Segundo intento de guardado falló');
                    }
                }
                
            } catch (error) {
                console.log(`❌ Error crítico en guardado con validación:`);
                console.log(`   Error: ${error.message}`);
                console.log(`   Stack:`, error.stack);
                return { success: false, error: error.message, details: error.stack };
            }
        }
        
        function updateActiveImageInfo() {
            const infoPanel = document.getElementById('activeImageInfo');
            
            if (!currentActiveImage) {
                infoPanel.style.display = 'none';
                currentImageHasChanges = false; // Resetear cambios cuando no hay imagen
                updateSaveStatusIndicator(); // Actualizar indicador cuando no hay imagen
                return;
            }
            
            infoPanel.style.display = 'block';
            
            // Actualizar detalles
            document.getElementById('activeImageName').textContent = currentActiveImage.name;
            
            // Actualizar indicador de estado de guardado
            updateSaveStatusIndicator();
            
            // Determinar estado
            let status;
            if (currentActiveImage.batches && currentActiveImage.batches.length > 0) {
                status = 'Con Lotes Asignados';
            } else if (currentActiveImage.status === 'detected') {
                status = 'Detectado';
            } else if (currentActiveImage.status === 'editing') {
                status = 'En Edición';
            } else if (currentActiveImage.status === 'uploaded') {
                status = 'Cargado';
            } else {
                status = 'Procesando';
            }
            
            document.getElementById('activeImageStatus').textContent = status;
            // Calcular suma de slabs en lotes
            let slabsInBatches = 0;
            if (currentActiveImage.batches && currentActiveImage.batches.length > 0) {
                slabsInBatches = currentActiveImage.batches.reduce((total, batch) => total + batch.points.length, 0);
            }
            document.getElementById('activeImageSlabs').textContent = slabsInBatches;
            
            // Mostrar números de lotes y detalle
            if (currentActiveImage.batches && currentActiveImage.batches.length > 0) {
                const batchNumbers = currentActiveImage.batches.map(batch => batch.number).sort((a, b) => a - b);
                document.getElementById('activeImageBatches').textContent = batchNumbers.join(', ');
                
                // Mostrar detalle por lote
                const batchDetails = document.getElementById('batchDetails');
                const batchDetailList = document.getElementById('batchDetailList');
                
                batchDetails.style.display = 'block';
                
                const detailsHtml = currentActiveImage.batches
                    .sort((a, b) => a.number - b.number)
                    .map(batch => {
                        const batchColor = getBatchColor(batch.number);
                        return `
                            <div class="batch-detail-item" style="border-left: 4px solid ${batchColor};">
                                <div style="display: flex; flex-direction: column; flex: 1;">
                                    <span class="batch-number">Lote 
                                        <span class="editable-batch-number" 
                                              data-batch-id="${batch.number}" 
                                              onclick="editarNumeroLote(${batch.number})"
                                              style="cursor: pointer; background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 4px; text-decoration: underline;"
                                              title="Click para editar">
                                            ${batch.number}
                                        </span>
                                    </span>
                                    <span class="batch-count">${batch.points.length} slabs</span>
                                </div>
                                <button class="delete-batch-btn" onclick="deleteBatch(${batch.number})">
                                    🗑️
                                </button>
                            </div>
                        `;
                    }).join('');
                
                batchDetailList.innerHTML = detailsHtml;
            } else {
                document.getElementById('activeImageBatches').textContent = '-';
                document.getElementById('batchDetails').style.display = 'none';
            }
        }
        
        function deleteImage(imageId) {
            if (!confirm('¿Estás seguro de eliminar esta imagen?')) return;
            
            const index = uploadedImages.findIndex(img => img.id === imageId);
            if (index === -1) return;
            
            const imageObj = uploadedImages[index];
            
            // Si es la imagen activa, limpiar
            if (currentActiveImage && currentActiveImage.id === imageId) {
                hideResults();
                hidePreview();
                document.getElementById('noActiveImage').style.display = 'block';
                currentActiveImage = null;
                currentFile = null;
                manualPoints = [];
                batches = [];
            }
            
            // Eliminar de la lista
            uploadedImages.splice(index, 1);
            
            // Actualizar interfaz
            updateImagesGrid();
            updateActiveImageInfo();
            updateImageNavigation();
            
            // Si no hay imágenes activas pero hay otras, seleccionar la primera
            if (!currentActiveImage && uploadedImages.length > 0) {
                selectImage(uploadedImages[0].id);
            }
            
            showAlert(`Imagen eliminada: ${imageObj.name}`, 'success');
        }
        
        function deleteCurrentImage() {
            if (currentActiveImage) {
                deleteImage(currentActiveImage.id);
            }
        }
        
        function showPreviewForImage(imageObj) {
            const container = document.getElementById('previewContainer');
            container.innerHTML = `<img src="${imageObj.originalImageSrc}" alt="Vista previa" id="previewImg">`;
            document.getElementById('previewSection').style.display = 'block';
            
            // Agregar zoom functionality
            setTimeout(() => {
                addZoomFunctionality('previewImg');
            }, 100);
        }
        
        function showResultsForImage(imageObj) {
            console.log(`🎯 MOSTRANDO RESULTADOS para: ${imageObj.name}`);
            console.log(`   📊 Manual Points a cargar: ${imageObj.manualPoints?.length || 0}`);
            console.log(`   📦 Batches a cargar: ${imageObj.batches?.length || 0}`);
            
            // Cargar detecciones previas CON DATOS PERSISTENTES
            manualPoints = [...(imageObj.manualPoints || [])];
            batches = [...(imageObj.batches || [])];
            nextPointId = imageObj.nextPointId || 1;
            
            // Ocultar vista previa
            document.getElementById('previewSection').style.display = 'none';
            
            // Mostrar imagen original (sin puntos de YOLO)
            const container = document.getElementById('imageContainer');
            container.innerHTML = `<img src="${imageObj.originalImageSrc}" alt="Imagen para edición" id="resultImg">`;
            
            // Configurar modo edición
            setTimeout(() => {
                setupEditMode();
                renderPoints();
                console.log(`✅ PUNTOS RENDERIZADOS: ${manualPoints.length} slabs, ${batches.length} lotes`);
            }, 100);
            
            // Mostrar secciones
            document.getElementById('resultSection').style.display = 'block';
            document.getElementById('modeSelector').style.display = 'block';
            isEditMode = true;
            
            // ACTIVAR MODO LOTES POR DEFECTO AL CARGAR IMAGEN EXISTENTE
            setTimeout(() => {
                switchEditMode('batches');
                console.log('📦 Modo lotes activado por defecto al cargar imagen existente');
            }, 200);
            
            // NO cambiar el estado - mantener el estado persistente original
        }

        function detectSlabs() {
            if (!currentFile) {
                showAlert('❌ No hay imagen seleccionada', 'error');
                return;
            }
            
            if (!currentActiveImage) {
                showAlert('❌ No hay imagen activa', 'error');
                return;
            }

            const confidence = parseFloat(confidenceSlider.value);
            
            // Mostrar loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('detectBtn').disabled = true;
            hideResults();

            fetch('/detect', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    filepath: currentFile.filepath,
                    confidence: confidence
                })
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('detectBtn').disabled = false;

                if (data.success) {
                    // Guardar datos de detección en la imagen activa
                    currentActiveImage.detectionData = data;
                    
                    // LIMPIAR LOTES AL RE-DETECTAR y cambiar estado a 'detected'
                    currentActiveImage.batches = [];
                    batches = []; // LIMPIAR VARIABLE GLOBAL TAMBIÉN
                    currentActiveImage.status = 'detected';
                    
                    // GUARDAR SOLO SI HAY DATOS SIGNIFICATIVOS (puntos manuales agregados)
                    // La detección por sí sola NO justifica crear un registro persistente
                    // Se guardará automáticamente cuando el usuario agregue puntos manuales o lotes
                    console.log('🎯 Detección completada - Datos se guardarán cuando se agreguen puntos manuales o lotes');
                    
                    showResults(data);
                    updateImagesGrid();
                    showAlert(`✅ Detección completada: ${data.count} palanquillas encontradas`, 'success');
                } else {
                    showAlert(`❌ Error en detección: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('detectBtn').disabled = false;
                showAlert('❌ Error en detección', 'error');
            });
        }

        function showResults(data) {
            // Inicializar puntos manuales con detecciones YOLO
            manualPoints = data.detections.map((detection, index) => ({
                id: index + 1,
                x: detection.x,
                y: detection.y,
                confidence: detection.confidence,
                isOriginal: true,
                batchNumber: null,
                isSelected: false
            }));
            nextPointId = manualPoints.length + 1;
            
            // SINCRONIZAR CON IMAGEN ACTIVA
            if (currentActiveImage) {
                currentActiveImage.manualPoints = [...manualPoints];
                currentActiveImage.nextPointId = nextPointId;
                currentActiveImage.batches = []; // ASEGURAR que esté limpio
                currentActiveImage.status = 'detected'; // FORZAR estado detectado
            }
            
            // Ocultar vista previa
            document.getElementById('previewSection').style.display = 'none';
            
            // Mostrar imagen original (sin puntos de YOLO)
            const container = document.getElementById('imageContainer');
            container.innerHTML = `<img src="${originalImageSrc}" alt="Imagen para edición" id="resultImg">`;
            
            // Configurar modo edición
            setTimeout(() => {
                setupEditMode();
                renderPoints();
            }, 100);
            
            // Mostrar secciones
            document.getElementById('resultSection').style.display = 'block';
            document.getElementById('modeSelector').style.display = 'block';
            
            // ACTIVAR MODO LOTES POR DEFECTO DESPUÉS DE DETECCIÓN
            setTimeout(() => {
                switchEditMode('batches'); // Forzar modo lotes
                console.log('📦 Modo lotes activado por defecto después de detección');
            }, 200);
            isEditMode = true;
            
            // Activar automáticamente el modo "Selección de Lotes"
            switchEditMode('batches');
            
            // Scroll a resultados
            document.getElementById('resultSection').scrollIntoView({ behavior: 'smooth' });
        }

        function hideResults() {
            document.getElementById('resultSection').style.display = 'none';
            document.getElementById('modeSelector').style.display = 'none';
            isEditMode = false;
            editModeType = 'points';
            selectedSlabs = [];
            manualPoints = [];
            resetImageTransform();
            // Mostrar vista previa nuevamente si existe currentFile
            if (currentFile) {
                document.getElementById('previewSection').style.display = 'block';
            }
        }

        function previewImage() {
            if (currentActiveImage && currentActiveImage.file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const container = document.getElementById('previewContainer');
                    container.innerHTML = `<img src="${e.target.result}" alt="Preview sin detecciones" id="previewImg">`;
                    document.getElementById('previewSection').style.display = 'block';
                    
                    // Ocultar resultados si existen
                    hideResults();
                    
                    // Habilitar zoom
                    addZoomFunctionality();
                    
                    showAlert('✅ Preview de imagen sin detecciones mostrado', 'success');
                };
                reader.readAsDataURL(currentActiveImage.file);
            } else {
                showAlert('❌ No hay imagen seleccionada para preview', 'error');
            }
        }
        
        function previewCurrentImage() {
            console.log('🔴 BUTTON PRESSED - previewCurrentImage() ejecutada');
            console.log('currentActiveImage:', currentActiveImage);
            console.log('currentActiveImage.detectionData:', currentActiveImage ? currentActiveImage.detectionData : 'No hay imagen activa');
            
            // Solo funciona si hay detecciones ejecutadas
            if (!currentActiveImage || !currentActiveImage.detectionData) {
                console.log('❌ No hay imagen o no hay detectionData');
                showAlert('❌ El preview solo funciona en imágenes con detección ejecutada', 'error');
                return;
            }
            
            // Toggle simple entre imagen original y imagen con detecciones
            isPreviewMode = !isPreviewMode;
            console.log('isPreviewMode cambiado a:', isPreviewMode);
            
            if (isPreviewMode) {
                // Mostrar imagen original sin detecciones
                console.log('🟡 Llamando showOriginalImage()');
                showOriginalImage();
            } else {
                // Mostrar imagen con detecciones
                console.log('🟢 Llamando showDetectedImage()');
                showDetectedImage();
            }
            
            // Actualizar botón
            updatePreviewButtonText();
        }
        
        function showOriginalImage() {
            console.log('📷 === EJECUTANDO showOriginalImage() ===');
            
            // Cambiar a imagen original
            const resultImg = document.getElementById('resultImg');
            if (resultImg && originalImageSrc) {
                resultImg.src = originalImageSrc;
                console.log('✅ Imagen cambiada a original');
            }
            
            // OCULTAR todos los puntos de detección (elementos DIV con clase .point)
            const pointElements = document.querySelectorAll('.point');
            console.log('Point elements encontrados:', pointElements.length);
            
            pointElements.forEach((point, index) => {
                point.style.display = 'none';
                console.log(`✅ Point ${index} ocultado`);
            });
            
            // También ocultar SVG overlays de selección
            const svgOverlays = document.querySelectorAll('svg');
            svgOverlays.forEach((svg, index) => {
                if (svg.id === 'selectionOverlay' || svg.classList.contains('selection-overlay')) {
                    svg.style.display = 'none';
                    console.log(`✅ SVG selection overlay ${index} ocultado`);
                }
            });
            
            console.log('📷 === IMAGEN ORIGINAL MOSTRADA ===');
        }
        
        function showDetectedImage() {
            console.log('🎯 === EJECUTANDO showDetectedImage() ===');
            
            // Volver a imagen original como base
            const resultImg = document.getElementById('resultImg');
            if (resultImg && originalImageSrc) {
                resultImg.src = originalImageSrc;
                console.log('✅ Imagen restaurada a original como base');
            }
            
            // MOSTRAR todos los puntos de detección (elementos DIV con clase .point)
            const pointElements = document.querySelectorAll('.point');
            console.log('Point elements encontrados:', pointElements.length);
            
            pointElements.forEach((point, index) => {
                point.style.display = 'block';
                console.log(`✅ Point ${index} mostrado`);
            });
            
            // Mostrar SVG overlays de selección
            const svgOverlays = document.querySelectorAll('svg');
            svgOverlays.forEach((svg, index) => {
                if (svg.id === 'selectionOverlay' || svg.classList.contains('selection-overlay')) {
                    svg.style.display = 'block';
                    console.log(`✅ SVG selection overlay ${index} mostrado`);
                }
            });
            
            // Re-renderizar puntos para asegurar que se muestren
            console.log('🔄 Re-renderizando puntos...');
            setTimeout(() => {
                renderPoints();
                console.log('✅ renderPoints() ejecutado');
            }, 50);
            
            
            console.log('🎯 === DETECCIONES MOSTRADAS ===');
        }
        
        function updatePreviewButtonText() {
            const previewBtn = document.getElementById('previewBtn');
            if (previewBtn) {
                if (isPreviewMode) {
                    previewBtn.innerHTML = '🎯 Ver Detecciones';
                } else {
                    previewBtn.innerHTML = '👁️ Ver Original';
                }
            }
        }

        function showPreview(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                originalImageSrc = e.target.result;
                const container = document.getElementById('previewContainer');
                container.innerHTML = `<img src="${e.target.result}" alt="Vista previa" id="previewImg">`;
                document.getElementById('previewSection').style.display = 'block';
                    
                // Agregar zoom functionality
                setTimeout(() => {
                    addZoomFunctionality('previewImg');
                }, 100);
                
                // Scroll a preview
                document.getElementById('previewSection').scrollIntoView({ behavior: 'smooth' });
            };
            reader.readAsDataURL(file);
        }

        function hidePreview() {
            document.getElementById('previewSection').style.display = 'none';
        }

        function setupEditMode() {
            const img = document.getElementById('resultImg');
            const container = document.getElementById('imageContainer');
            
            if (!img || !container) return;
            
            container.classList.add('edit-mode');
            
            // Event listeners para edición - esperar a que se cree el transformContainer
            setTimeout(() => {
                const transformContainer = document.getElementById('transformContainer');
                if (!transformContainer) return;
                
                // SISTEMA ROBUSTO: Calcular coordenadas precisas SIEMPRE
                function getAccurateCoordinates(e) {
                    // Obtener el rect de la imagen REAL en su posición actual
                    const imgRect = img.getBoundingClientRect();
                    
                    // Coordenadas relativas a la imagen visible
                    const relativeX = e.clientX - imgRect.left;
                    const relativeY = e.clientY - imgRect.top;
                    
                    // Convertir a coordenadas de imagen natural (sin importar zoom/pan)
                    const naturalX = (relativeX / imgRect.width) * img.naturalWidth;
                    const naturalY = (relativeY / imgRect.height) * img.naturalHeight;
                    
                    return {
                        relativeX,
                        relativeY,
                        naturalX,
                        naturalY,
                        imgRect,
                        valid: naturalX >= 0 && naturalY >= 0 && naturalX <= img.naturalWidth && naturalY <= img.naturalHeight
                    };
                }
                
                transformContainer.addEventListener('mousedown', function(e) {
                    if (!isEditMode) return;
                    
                    // SOLO procesar botón principal (izquierdo) para edición
                    if (e.button !== 0) return;
                    
                    // Si se presiona CTRL + click izquierdo, es para paneo, NO para edición
                    if (e.ctrlKey) return;
                    
                    // En modo lotes, NO permitir edición de puntos
                    if (editModeType === 'batches' && e.target.classList.contains('point')) {
                        e.preventDefault();
                        return;
                    }
                    
                    // Obtener coordenadas precisas con el nuevo sistema
                    const coords = getAccurateCoordinates(e);
                    
                    // Debug
                    console.log('Coordenadas precisas:', coords);
                    
                    if (editModeType === 'slabs') {
                        // Verificar que el click esté dentro de la imagen
                        if (!coords.valid) {
                            console.log('Click fuera de imagen');
                            return;
                        }
                        
                        const clickX = coords.naturalX;
                        const clickY = coords.naturalY;
                        
                        console.log('Punto creado en:', clickX, clickY);
                        
                        // Si se hizo click directamente sobre un punto
                        if (e.target.classList.contains('point')) {
                            const pointId = parseInt(e.target.dataset.pointId);
                            const pointIndex = manualPoints.findIndex(p => p.id === pointId);
                            
                            if (pointIndex >= 0) {
                                // Reemplazar punto existente (mover a nueva posición)
                                manualPoints[pointIndex] = {
                                    ...manualPoints[pointIndex],
                                    x: Math.round(clickX),
                                    y: Math.round(clickY),
                                    confidence: 1.0,
                                    isOriginal: false
                                };
                                
                                renderPoints();
                                autoSaveCurrentImageData(); // AUTO-GUARDADO
                            }
                            e.preventDefault();
                            return;
                        }
                        
                        // ===== RADIO INTELIGENTE PARA AGREGAR PUNTOS =====
                        const baseSearchRadius = 15; // Radio base (similar al de eliminación)
                        let currentZoom = 1; // Zoom por defecto
                        
                        // Obtener zoom actual del contenedor si existe
                        if (container._zoomData && container._zoomData.scale) {
                            currentZoom = container._zoomData.scale;
                        }
                        
                        // Radio escalado: más zoom = radio más grande para facilitar detección
                        const searchRadius = baseSearchRadius * currentZoom;
                        
                        console.log(`🎯 Radio inteligente para agregar: ${searchRadius.toFixed(1)}px (base: ${baseSearchRadius}px × zoom: ${currentZoom.toFixed(2)}x)`);
                        
                        // Buscar si hay un punto existente cerca (en coordenadas de pantalla)
                        const existingPointIndex = manualPoints.findIndex(point => {
                            // Convertir punto existente a coordenadas de pantalla
                            const pointScreenX = (point.x / img.naturalWidth) * coords.imgRect.width;
                            const pointScreenY = (point.y / img.naturalHeight) * coords.imgRect.height;
                            
                            // Distancia en coordenadas de pantalla
                            const distance = Math.sqrt(
                                Math.pow(pointScreenX - coords.relativeX, 2) + 
                                Math.pow(pointScreenY - coords.relativeY, 2)
                            );
                            return distance <= searchRadius;
                        });
                        
                        if (existingPointIndex >= 0) {
                            // Reemplazar punto existente
                            manualPoints[existingPointIndex] = {
                                ...manualPoints[existingPointIndex],
                                x: Math.round(clickX),
                                y: Math.round(clickY),
                                confidence: 1.0,
                                isOriginal: false
                            };
                        } else {
                            // Agregar nuevo punto
                            manualPoints.push({
                                id: nextPointId++,
                                x: Math.round(clickX),
                                y: Math.round(clickY),
                                confidence: 1.0,
                                isOriginal: false,
                                batchNumber: null,
                                isSelected: false
                            });
                        }
                        
                        renderPoints();
                        autoSaveCurrentImageData(); // AUTO-GUARDADO
                        e.preventDefault();
                        
                    } else if (editModeType === 'batches') {
                        // Modo de selección de lotes (selección libre)
                        if (!e.target.classList.contains('point')) {
                            isDrawing = true;
                            selectionPath = [];
                            
                            // Iniciar dibujado de selección libre
                            startFreeDrawing();
                            e.preventDefault();
                        }
                    }
                });
                
                transformContainer.addEventListener('mousemove', function(e) {
                    if (!isEditMode || editModeType !== 'batches' || !isDrawing) return;
                    
                    // ENFOQUE REVOLUCIONARIO: Coordenadas absolutas de pantalla
                    const img = document.getElementById('resultImg');
                    if (!img) return;
                    
                    // Verificar que el mouse esté sobre la imagen
                    const imgRect = img.getBoundingClientRect();
                    if (e.clientX < imgRect.left || e.clientX > imgRect.right ||
                        e.clientY < imgRect.top || e.clientY > imgRect.bottom) {
                        return; // Fuera de la imagen
                    }
                    
                    // Usar coordenadas ABSOLUTAS de pantalla (sin conversiones)
                    const screenX = e.clientX;
                    const screenY = e.clientY;
                    
                    // Añadir punto al path (coordenadas de pantalla)
                    const lastPoint = selectionPath[selectionPath.length - 1];
                    if (!lastPoint || 
                        Math.abs(screenX - lastPoint.x) > 3 || 
                        Math.abs(screenY - lastPoint.y) > 3) {
                        selectionPath.push({ x: screenX, y: screenY });
                        drawFreeSelection();
                        
                        console.log('Punto ABSOLUTO añadido:', { 
                            screenCoords: { x: screenX, y: screenY },
                            imgRect,
                            pathLength: selectionPath.length 
                        });
                    }
                });
                
                transformContainer.addEventListener('mouseup', function(e) {
                    if (!isEditMode || editModeType !== 'batches' || !isDrawing) return;
                    
                    isDrawing = false;
                    
                    // Cerrar el path de selección libre
                    if (selectionPath.length > 3) {
                        // Cerrar el path conectando el último punto con el primero
                        selectionPath.push(selectionPath[0]);
                        selectPointsInPath(selectionPath);
                        
                        // ABRIR POPUP AUTOMÁTICAMENTE DESPUÉS DE SELECCIÓN
                        setTimeout(() => {
                            const selectedPoints = manualPoints.filter(point => point.isSelected);
                            if (selectedPoints.length > 0) {
                                openBatchModal();
                            }
                        }, 100); // Pequeño delay para que termine la renderización
                    }
                });
                
                // Event listener para eliminar con click derecho (SOLO en modo slabs) - RADIO INTELIGENTE
                transformContainer.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    if (!isEditMode || editModeType !== 'slabs') return;
                    
                    // No procesar si se está presionando CTRL (reservado para paneo)
                    if (e.ctrlKey) return;
                    
                    // ===== RADIO INTELIGENTE DE ELIMINACIÓN =====
                    const baseRadius = 15; // Radio base reducido (era 30px)
                    let currentZoom = 1; // Zoom por defecto
                    
                    // Obtener zoom actual del contenedor si existe
                    if (container._zoomData && container._zoomData.scale) {
                        currentZoom = container._zoomData.scale;
                    }
                    
                    // Radio escalado: más zoom = radio más grande para facilitar eliminación
                    const smartRadius = baseRadius * currentZoom;
                    
                    console.log(`🎯 Radio inteligente: ${smartRadius.toFixed(1)}px (base: ${baseRadius}px × zoom: ${currentZoom.toFixed(2)}x)`);
                    
                    // Obtener coordenadas del click
                    const coords = getAccurateCoordinates(e);
                    if (!coords || !coords.valid) return;
                    
                    // Buscar punto más cercano dentro del radio inteligente
                    let closestPoint = null;
                    let closestDistance = Infinity;
                    let closestIndex = -1;
                    
                    manualPoints.forEach((point, index) => {
                        // Convertir punto a coordenadas de pantalla
                        const pointScreenX = (point.x / img.naturalWidth) * coords.imgRect.width;
                        const pointScreenY = (point.y / img.naturalHeight) * coords.imgRect.height;
                        
                        // Calcular distancia en píxeles de pantalla
                        const distance = Math.sqrt(
                            Math.pow(pointScreenX - coords.relativeX, 2) + 
                            Math.pow(pointScreenY - coords.relativeY, 2)
                        );
                        
                        // Si está dentro del radio inteligente y es el más cercano
                        if (distance <= smartRadius && distance < closestDistance) {
                            closestDistance = distance;
                            closestPoint = point;
                            closestIndex = index;
                        }
                    });
                    
                    // Eliminar el punto más cercano si se encontró uno
                    if (closestPoint !== null) {
                        console.log(`🗑️ Eliminando punto ID: ${closestPoint.id} (distancia: ${closestDistance.toFixed(1)}px)`);
                        manualPoints = manualPoints.filter(p => p.id !== closestPoint.id);
                        renderPoints();
                        autoSaveCurrentImageData(); // AUTO-GUARDADO
                    } else {
                        console.log('❌ No hay puntos cerca para eliminar');
                    }
                });
                
                // Manejo simple y efectivo del botón medio
                transformContainer.addEventListener('auxclick', function(e) {
                    if (e.button === 1) {
                        e.preventDefault();
                    }
                });
            }, 200);
            
            // Agregar zoom con puntos
            addZoomWithPoints('resultImg');
        }

        function renderPoints() {
            const img = document.getElementById('resultImg');
            const transformContainer = document.getElementById('transformContainer');
            
            if (!img || !transformContainer) return;
            
            // Obtener slabs existentes
            const existingPoints = transformContainer.querySelectorAll('.point');
            const existingPointsMap = new Map();
            existingPoints.forEach(p => {
                existingPointsMap.set(parseInt(p.dataset.pointId), p);
            });
            
            // Actualizar o crear slabs
            manualPoints.forEach(slab => {
                let slabElement = existingPointsMap.get(slab.id);
                
                if (!slabElement) {
                    // Crear nuevo slab
                    slabElement = document.createElement('div');
                    slabElement.dataset.pointId = slab.id;
                    transformContainer.appendChild(slabElement);
                }
                
                // Actualizar clases y contenido
                let className = 'point';
                if (slab.isSelected) {
                    className += ' selected';
                } else if (slab.batchNumber) {
                    className += ' batch';
                } else if (slab.isOriginal) {
                    className += ' original';
                } else {
                    className += ' manual';
                }
                slabElement.className = className;
                
                // Aplicar color específico del lote
                if (slab.batchNumber) {
                    const batchColor = getBatchColor(slab.batchNumber);
                    slabElement.style.backgroundColor = batchColor;
                    slabElement.textContent = slab.batchNumber;
                    slabElement.title = `Slab ${slab.id} - Lote: ${slab.batchNumber} - Confidence: ${slab.confidence.toFixed(2)}`;
                } else {
                    // Restaurar color por defecto y mostrar confidence
                    slabElement.style.backgroundColor = '';
                    slabElement.textContent = slab.confidence.toFixed(2);
                    slabElement.title = `Slab ${slab.id} - Confidence: ${slab.confidence.toFixed(2)}`;
                }
                
                // Actualizar posición (siempre)
                updatePointPosition(slabElement, slab, img);
                existingPointsMap.delete(slab.id);
            });
            
            // Remover slabs que ya no existen
            existingPointsMap.forEach(slabElement => {
                slabElement.remove();
            });
        }

        function updatePointPosition(pointElement, point, img) {
            // Convertir coordenadas de imagen original a coordenadas relativas a la imagen mostrada
            const x = (point.x / img.naturalWidth) * img.clientWidth;
            const y = (point.y / img.naturalHeight) * img.clientHeight;
            
            // Posicionar directamente
            pointElement.style.left = x + 'px';
            pointElement.style.top = y + 'px';
        }

        function resetImageTransform() {
            imageScale = 1;
            imageTranslateX = 0;
            imageTranslateY = 0;
        }

        function addZoomWithPoints(imgId) {
            const img = document.getElementById(imgId);
            const container = img.parentElement;
            
            // Crear contenedor interno que se transformará
            const transformContainer = document.createElement('div');
            transformContainer.id = 'transformContainer';
            transformContainer.style.cssText = `
                position: relative;
                display: inline-block;
                transform-origin: center center;
                transition: transform 0.1s ease-out;
            `;
            
            // Mover imagen al contenedor interno
            container.insertBefore(transformContainer, img);
            transformContainer.appendChild(img);
            
            let scale = 1;
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let translateX = 0;
            let translateY = 0;
            
            // GUARDAR datos de zoom en el contenedor para acceso desde edición
            container._zoomData = {
                scale: scale,
                translateX: translateX,
                translateY: translateY
            };
            

            function constrainPosition() {
                const containerRect = container.getBoundingClientRect();
                const transformRect = transformContainer.getBoundingClientRect();
                
                const containerW = containerRect.width - 40;
                const containerH = containerRect.height - 40;
                const transformW = transformRect.width;
                const transformH = transformRect.height;

                if (transformW > containerW) {
                    const maxTranslateX = (transformW - containerW) / 2;
                    translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, translateX));
                } else {
                    translateX = 0;
                }

                if (transformH > containerH) {
                    const maxTranslateY = (transformH - containerH) / 2;
                    translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, translateY));
                } else {
                    translateY = 0;
                }
            }

            function updateTransform() {
                const transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                transformContainer.style.transform = transform;
                
                // ACTUALIZAR datos guardados
                container._zoomData = {
                    scale: scale,
                    translateX: translateX,
                    translateY: translateY
                };
            }

            // Zoom con scroll
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * delta;
                
                if (newScale >= 1 && newScale <= 3.6) {
                    const prevScale = scale;
                    scale = newScale;
                    
                    const scaleRatio = scale / prevScale;
                    translateX *= scaleRatio;
                    translateY *= scaleRatio;
                    
                    updateTransform();
                    constrainPosition();
                    updateTransform();
                    
                    if (scale > 1) {
                        container.classList.add('zoomed');
                        img.style.cursor = 'grab';
                    } else {
                        container.classList.remove('zoomed');
                        img.style.cursor = 'crosshair';
                        translateX = 0;
                        translateY = 0;
                        updateTransform();
                    }
                }
            });

            // SOLUCIÓN ROBUSTA: Permitir botón scroll para pan Y mantener edición precisa
            transformContainer.addEventListener('mousedown', function(e) {
                // Botón medio (1) para pan cuando hay zoom (mantener funcionalidad original)
                if (scale > 1 && e.button === 1) {
                    isDragging = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    img.style.cursor = 'grabbing';
                    e.preventDefault();
                }
                // NUEVO: CTRL + click izquierdo (0) para pan cuando hay zoom
                else if (scale > 1 && e.button === 0 && e.ctrlKey) {
                    isDragging = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    img.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging && !isDrawing) {
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    
                    constrainPosition();
                    updateTransform();
                }
            });

            document.addEventListener('mouseup', function(e) {
                if (isDragging) {
                    isDragging = false;
                    img.style.cursor = scale > 1 ? 'grab' : 'crosshair';
                }
            });
            
            // Permitir auxclick del botón medio para funcionalidad nativa
            transformContainer.addEventListener('auxclick', function(e) {
                if (e.button === 1) {
                    e.preventDefault(); // Solo prevenir acción por defecto, no bloquear
                }
            });

            // Reset zoom con doble click
            img.addEventListener('dblclick', function() {
                scale = 1;
                translateX = 0;
                translateY = 0;
                updateTransform();
                container.classList.remove('zoomed');
                img.style.cursor = 'crosshair';
            });
        }

        function addZoomFunctionality(imgId) {
            const img = document.getElementById(imgId);
            const container = img.parentElement;
            let scale = 1;
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let translateX = 0;
            let translateY = 0;

            function constrainPosition() {
                const containerRect = container.getBoundingClientRect();
                const imgRect = img.getBoundingClientRect();
                
                const containerW = containerRect.width - 40;
                const containerH = containerRect.height - 40;
                const imgW = imgRect.width;
                const imgH = imgRect.height;

                if (imgW > containerW) {
                    const maxTranslateX = (imgW - containerW) / 2;
                    translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, translateX));
                } else {
                    translateX = 0;
                }

                if (imgH > containerH) {
                    const maxTranslateY = (imgH - containerH) / 2;
                    translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, translateY));
                } else {
                    translateY = 0;
                }
            }

            // Zoom con scroll
            container.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = scale * delta;
                
                if (newScale >= 1 && newScale <= 3.6) {
                    const prevScale = scale;
                    scale = newScale;
                    
                    const scaleRatio = scale / prevScale;
                    translateX *= scaleRatio;
                    translateY *= scaleRatio;
                    
                    img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                    
                    setTimeout(() => {
                        constrainPosition();
                        img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                    }, 10);
                    
                    if (scale > 1) {
                        container.classList.add('zoomed');
                        img.style.cursor = 'grab';
                    } else {
                        container.classList.remove('zoomed');
                        img.style.cursor = 'zoom-in';
                        translateX = 0;
                        translateY = 0;
                        img.style.transform = `translate(0px, 0px) scale(1)`;
                    }
                }
            });

            // Drag para mover imagen cuando está en zoom
            img.addEventListener('mousedown', function(e) {
                if (scale > 1) {
                    isDragging = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    img.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    
                    constrainPosition();
                    img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    img.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
                }
            });

            // Reset zoom con doble click
            img.addEventListener('dblclick', function() {
                scale = 1;
                translateX = 0;
                translateY = 0;
                img.style.transform = 'translate(0px, 0px) scale(1)';
                container.classList.remove('zoomed');
                img.style.cursor = 'zoom-in';
            });
        }

        function showAlert(message, type) {
            // Remover alertas anteriores
            const existingAlerts = document.querySelectorAll('.alert');
            existingAlerts.forEach(alert => alert.remove());
            
            // Crear nueva alerta flotante
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.style.display = 'flex';
            alert.style.justifyContent = 'space-between';
            alert.style.alignItems = 'center';
            alert.style.padding = '12px 15px';
            
            // Crear contenido de mensaje
            const messageSpan = document.createElement('span');
            messageSpan.textContent = message;
            alert.appendChild(messageSpan);
            
            // Crear botón de cierre
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '✕';
            closeBtn.style.background = 'none';
            closeBtn.style.border = 'none';
            closeBtn.style.color = 'inherit';
            closeBtn.style.fontSize = '16px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.marginLeft = '10px';
            closeBtn.style.padding = '2px 6px';
            closeBtn.style.borderRadius = '3px';
            closeBtn.title = 'Cerrar';
            
            // Función para cerrar la alerta
            function closeAlert() {
                if (alert.parentNode) {
                    alert.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => {
                        if (alert.parentNode) {
                            alert.parentNode.removeChild(alert);
                        }
                    }, 300);
                }
            }
            
            closeBtn.onclick = closeAlert;
            alert.appendChild(closeBtn);
            
            // Insertar directamente en body para que flote
            document.body.appendChild(alert);
            
            // Remover después de 6 segundos (más tiempo para poder cerrar manualmente)
            setTimeout(closeAlert, 6000);
        }

        // Evitar doble click en upload area
        document.getElementById('uploadArea').addEventListener('click', function(e) {
            // Solo abrir file dialog si no es el botón
            if (!e.target.classList.contains('btn')) {
                document.getElementById('fileInput').click();
            }
        });

        // ===== GUARDADO AUTOMÁTICO AL CERRAR/REFRESCAR =====
        
        window.addEventListener('beforeunload', function(e) {
            // Guardar datos antes de cerrar/refrescar
            if (currentActiveImage) {
                console.log('🚨 GUARDADO DE EMERGENCIA antes de cerrar página');
                saveCurrentImageDataNow(); // Guardado síncrono
            }
        });
        
        // Guardado periódico cada 30 segundos - Solo si hay datos significativos
        setInterval(() => {
            if (currentActiveImage && hasSignificantData(currentActiveImage)) {
                console.log('🕒 GUARDADO PERIÓDICO (30s)');
                autoSaveCurrentImageData();
            } else if (currentActiveImage) {
                console.log('🚫 GUARDADO PERIÓDICO CANCELADO - No hay datos significativos');
            }
        }, 30000);
        
        
        // ===== INICIALIZACIÓN DE LA APLICACIÓN =====
        
        // Cargar datos persistentes al inicio (no bloqueante)
        window.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Inicializando AZA Slab Counter v11.0 - Sistema Industrial...');
            
            // Cargar datos persistentes en segundo plano
            loadPersistentData().then(persistedData => {
                if (persistedData && persistedData.images.length > 0) {
                    console.log(`📦 ${persistedData.images.length} imágenes encontradas en persistencia:`);
                    
                    // Mostrar detalles de cada imagen
                    persistedData.images.forEach(img => {
                        const manualCount = img.manualPoints?.length || 0;
                        const batchCount = img.batches?.length || 0;
                        const status = batchCount > 0 ? `✅ ${batchCount} lotes` : 
                                      manualCount > 0 ? `🎯 ${manualCount} slabs` : '📁 sin datos';
                        console.log(`   📷 ${img.name}: ${status}`);
                    });
                    
                    // Verificar si hay optimización reciente
                    const optimizedAt = persistedData.optimized_at;
                    const isOptimized = optimizedAt && (Date.now() - new Date(optimizedAt).getTime()) < 24 * 60 * 60 * 1000; // 24 horas
                    
                    if (isOptimized) {
                        console.log('✅ PERSISTENCIA OPTIMIZADA recientemente');
                        showAlert(`📦 PERSISTENCIA OPTIMIZADA: ${persistedData.images.length} imagen(es) con datos guardados. Las imágenes con lotes se restaurarán automáticamente.`, 'success');
                    } else {
                        console.log('🔧 Optimizando persistencia...');
                        optimizePersistentData().then(success => {
                            if (success) {
                                showAlert(`📦 PERSISTENCIA ROBUSTA: ${persistedData.images.length} imagen(es) optimizadas. Sube las mismas imágenes para restaurar automáticamente todos los lotes.`, 'success');
                            }
                        });
                    }
                } else {
                    console.log('📁 No hay datos persistentes previos - sistema listo para nuevas imágenes');
                }
            }).catch(error => {
                console.log('⚠️ Error inicializando persistencia:', error);
                showAlert('⚠️ Error cargando datos persistentes. Creando nuevo sistema de persistencia...', 'warning');
            });
        });

        // ===== FUNCIONES PARA SELECCIÓN DE LOTES =====

        function switchEditMode(mode) {
            editModeType = mode;
            
            // Limpiar cualquier operación en curso
            isDrawing = false;
            selectionPath = [];
            hideFreeSelection();
            
            // Resetear estados potencialmente problemáticos
            const transformContainer = document.getElementById('transformContainer');
            if (transformContainer) {
                transformContainer.style.pointerEvents = 'auto';
            }
            
            // Actualizar botones
            document.getElementById('slabsMode').classList.toggle('active', mode === 'slabs');
            document.getElementById('batchesMode').classList.toggle('active', mode === 'batches');
            
            // Mostrar/ocultar instrucciones según modo
            document.getElementById('slabsInstructions').style.display = mode === 'slabs' ? 'block' : 'none';
            document.getElementById('batchesInstructions').style.display = mode === 'batches' ? 'block' : 'none';
            
            // Limpiar selección
            clearSelection();
            
            // Cambiar cursor según modo
            const img = document.getElementById('resultImg');
            if (img) {
                img.style.cursor = mode === 'slabs' ? 'crosshair' : 'crosshair';
            }
        }


        function clearSelection() {
            selectedSlabs = [];
            manualPoints.forEach(slab => slab.isSelected = false);
            document.getElementById('selectedCount').textContent = '0';
            document.getElementById('assignBatchBtn').disabled = true;
            renderPoints();
            hideFreeSelection();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
        }

        // ===== FUNCIONES DE NAVEGACIÓN ENTRE IMÁGENES =====

        function scrollToSelectedImageInGrid(imageId) {
            if (!imageId) return;
            
            const grid = document.getElementById('imagesGrid');
            const imageElement = document.querySelector(`[data-image-id="${imageId}"]`);
            
            if (grid && imageElement) {
                // Hacer scroll al elemento seleccionado en el grid
                imageElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest',
                    inline: 'nearest'
                });
                console.log(`📍 Scroll automático a imagen seleccionada en grid: ${imageId}`);
            }
        }

        function previousImage() {
            if (!uploadedImages || uploadedImages.length <= 1) return;
            
            // Si no hay imagen activa, seleccionar la última
            if (!currentActiveImage) {
                console.log(`🔍 No hay imagen activa, seleccionando la última: índice ${uploadedImages.length - 1}`);
                const lastImageId = uploadedImages[uploadedImages.length - 1].id;
                selectImage(lastImageId, true); // isNavigation = true
                scrollToSelectedImageInGrid(lastImageId);
                return;
            }
            
            const currentIndex = uploadedImages.findIndex(img => img.id === currentActiveImage.id);
            if (currentIndex > 0) {
                console.log(`🔍 Navegando a imagen anterior: índice ${currentIndex - 1}`);
                const prevImageId = uploadedImages[currentIndex - 1].id;
                selectImage(prevImageId, true); // isNavigation = true
                scrollToSelectedImageInGrid(prevImageId);
            }
        }

        function nextImage() {
            if (!uploadedImages || uploadedImages.length <= 1) return;
            
            // Si no hay imagen activa, seleccionar la primera
            if (!currentActiveImage) {
                console.log(`🔍 No hay imagen activa, seleccionando la primera: índice 0`);
                const firstImageId = uploadedImages[0].id;
                selectImage(firstImageId, true); // isNavigation = true
                scrollToSelectedImageInGrid(firstImageId);
                return;
            }
            
            const currentIndex = uploadedImages.findIndex(img => img.id === currentActiveImage.id);
            if (currentIndex < uploadedImages.length - 1) {
                console.log(`🔍 Navegando a imagen siguiente: índice ${currentIndex + 1}`);
                const nextImageId = uploadedImages[currentIndex + 1].id;
                selectImage(nextImageId, true); // isNavigation = true
                scrollToSelectedImageInGrid(nextImageId);
            }
        }

        function updateImageNavigation() {
            const navigation = document.getElementById('imageNavigation');
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            const currentIndexSpan = document.getElementById('currentImageIndex');
            const totalImagesSpan = document.getElementById('totalImages');

            // Solo ocultar si hay menos de 2 imágenes
            if (!uploadedImages || uploadedImages.length <= 1) {
                navigation.style.display = 'none';
                return;
            }

            // Mostrar navegación cuando hay 2+ imágenes
            navigation.style.display = 'flex';

            // Si hay imagen activa, actualizar normalmente
            if (currentActiveImage) {
                const currentIndex = uploadedImages.findIndex(img => img.id === currentActiveImage.id);
                currentIndexSpan.textContent = currentIndex + 1;
                totalImagesSpan.textContent = uploadedImages.length;

                // Habilitar/deshabilitar botones según posición
                prevBtn.disabled = currentIndex <= 0;
                nextBtn.disabled = currentIndex >= uploadedImages.length - 1;

                console.log(`📊 Navegación actualizada: ${currentIndex + 1}/${uploadedImages.length} imágenes`);
            } else {
                // Si no hay imagen activa pero hay imágenes cargadas, mostrar estado por defecto
                currentIndexSpan.textContent = '1';
                totalImagesSpan.textContent = uploadedImages.length;
                
                // Habilitar ambos botones para permitir navegación
                prevBtn.disabled = false;
                nextBtn.disabled = false;
                
                console.log(`📊 Navegación disponible: ${uploadedImages.length} imágenes cargadas`);
            }
        }

        function updateSelectedCount() {
            const count = selectedSlabs.length;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('assignBatchBtn').disabled = count === 0;
            // No auto-guardar aquí porque es solo UI
        }

        async function assignBatchToSelected() {
            const batchNumber = parseInt(document.getElementById('batchNumber').value);
            
            // VERIFICAR DUPLICADOS USANDO EL GESTOR CENTRALIZADO
            console.log(`🚀 [assignBatchToSelected] Iniciando verificación de duplicados para lote ${batchNumber}`);
            try {
                const resultado = await historialManager.verificarLoteDuplicado(batchNumber);
                console.log(`📋 [assignBatchToSelected] Resultado de verificación:`, resultado);
                
                // Función para continuar con la creación del lote
                const continuarCreacion = async () => {
                    await crearLoteConPuntosSeleccionados(batchNumber);
                };
                
                if (resultado.existe) {
                    console.log(`🚨 [assignBatchToSelected] MOSTRANDO MODAL DUPLICADO: Lote ${batchNumber} ya existe`);
                    // Mostrar modal de duplicado y esperar confirmación del usuario
                    mostrarModalDuplicado(batchNumber, resultado, continuarCreacion);
                } else {
                    console.log(`✅ [assignBatchToSelected] Lote ${batchNumber} es único, continuando con creación`);
                    await continuarCreacion();
                }
            } catch (error) {
                console.error('❌ [assignBatchToSelected] Error en verificación de duplicados:', error);
                // Continuar con la creación incluso si hay error en verificación
                await crearLoteConPuntosSeleccionados(batchNumber);
            }
        }
        
        async function crearLoteConPuntosSeleccionados(batchNumber) {
            // Siempre crear un nuevo lote, incluso si el número ya existe
            const batch = {
                number: batchNumber,
                points: [],
                imageName: currentImageName,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                id: Date.now() + Math.random() // ID único para diferenciar lotes con mismo número
            };
            batches.push(batch);
            
            selectedSlabs.forEach(pointId => {
                const point = manualPoints.find(p => p.id === pointId);
                if (point) {
                    // Remover de lotes anteriores
                    batches.forEach(b => {
                        b.points = b.points.filter(pid => pid !== pointId);
                    });
                    
                    // Asignar al nuevo lote
                    point.batchNumber = batchNumber;
                    point.isSelected = false;
                    batch.points.push(pointId);
                }
            });
            
            // Limpiar lotes vacíos
            batches = batches.filter(b => b.points.length > 0);
            
            selectedSlabs = [];
            nextBatchNumber = Math.max(nextBatchNumber, batchNumber + 1);
            document.getElementById('batchNumber').value = nextBatchNumber;
            
            updateSelectedCount();
            renderPoints();
            hideFreeSelection();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
            updateImagesGrid(); // Actualizar estado en grid
            updateActiveImageInfo(); // Actualizar panel info
            
            // Guardar en historial CSV usando el gestor centralizado
            const guardadoExitoso = await historialManager.guardarLoteEnHistorial(
                currentImageName || 'imagen_sin_nombre', 
                batchNumber, 
                batch.points.length
            );
            
            if (guardadoExitoso) {
                showAlert(`✅ Lote ${batchNumber} creado con ${batch.points.length} slabs y guardado en historial`, 'success');
            } else {
                showAlert(`⚠️ Lote ${batchNumber} creado con ${batch.points.length} slabs pero hubo error guardando en historial`, 'warning');
            }
        }
        
        async function deleteBatch(batchNumber) {
            if (!confirm(`¿Estás seguro de eliminar el Lote ${batchNumber}?`)) {
                return;
            }
            
            // Encontrar el lote a eliminar
            const batchIndex = batches.findIndex(b => b.number === batchNumber);
            if (batchIndex === -1) {
                showAlert('❌ Lote no encontrado', 'error');
                return;
            }
            
            const batch = batches[batchIndex];
            
            // Remover asignación de lote de todos los puntos
            batch.points.forEach(pointId => {
                const point = manualPoints.find(p => p.id === pointId);
                if (point) {
                    point.batchNumber = null;
                    point.isSelected = false;
                }
            });
            
            // Eliminar el lote del array
            batches.splice(batchIndex, 1);
            
            // Actualizar interfaz
            renderPoints();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
            updateImagesGrid(); // Actualizar estado en grid
            updateActiveImageInfo(); // Actualizar panel info
            
            // Eliminar del historial CSV usando el gestor centralizado
            const eliminadoExitoso = await historialManager.eliminarLoteDelHistorial(
                currentImageName || 'imagen_sin_nombre',
                batchNumber
            );
            
            if (eliminadoExitoso) {
                showAlert(`✅ Lote ${batchNumber} eliminado de la interfaz y del historial`, 'success');
            } else {
                showAlert(`⚠️ Lote ${batchNumber} eliminado de la interfaz pero hubo error eliminando del historial`, 'warning');
            }
            
            console.log(`Lote ${batchNumber} eliminado exitosamente`);
        }

        function startFreeDrawing() {
            // ENFOQUE COMPLETAMENTE DIFERENTE: SVG OVERLAY
            const imageContainer = document.getElementById('imageContainer');
            if (!imageContainer) return;
            
            // Eliminar overlay anterior si existe
            const oldOverlay = document.getElementById('selectionOverlay');
            if (oldOverlay) {
                oldOverlay.remove();
            }
            
            // Crear SVG overlay que cubre TODA la ventana
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'selectionOverlay';
            svg.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                pointer-events: none;
                z-index: 1000;
            `;
            
            // Crear path para el dibujo
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.id = 'selectionPath';
            path.setAttribute('stroke', '#1947BA');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'rgba(72, 52, 212, 0.2)');
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            
            svg.appendChild(path);
            document.body.appendChild(svg);
            
            console.log('SVG overlay creado - V5 enfoque mejorado');
        }
        
        function drawFreeSelection() {
            const pathElement = document.getElementById('selectionPath');
            if (!pathElement || selectionPath.length < 2) return;
            
            // Construir path SVG con coordenadas absolutas de pantalla
            let pathData = `M ${selectionPath[0].x} ${selectionPath[0].y}`;
            
            // Añadir puntos suaves
            for (let i = 1; i < selectionPath.length; i++) {
                pathData += ` L ${selectionPath[i].x} ${selectionPath[i].y}`;
            }
            
            // Si está cerca del punto inicial, cerrar
            if (selectionPath.length > 3) {
                const first = selectionPath[0];
                const last = selectionPath[selectionPath.length - 1];
                const distance = Math.sqrt(
                    Math.pow(first.x - last.x, 2) + Math.pow(first.y - last.y, 2)
                );
                
                if (distance < 30) {
                    pathData += ' Z'; // Cerrar path
                }
            }
            
            pathElement.setAttribute('d', pathData);
            
            console.log('SVG path actualizado V5:', {
                pathData: pathData.substring(0, 100) + '...',
                points: selectionPath.length
            });
        }
        
        function hideFreeSelection() {
            const overlay = document.getElementById('selectionOverlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Función para verificar si un punto está dentro de un polígono (ray casting)
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                    (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function selectPointsInPath(path) {
            const img = document.getElementById('resultImg');
            if (!img || path.length < 3) return;
            
            selectedSlabs = [];
            
            // Obtener posición actual de la imagen en pantalla
            const imgRect = img.getBoundingClientRect();
            
            manualPoints.forEach(point => {
                // Convertir coordenadas del punto a coordenadas de pantalla
                const pointScreenX = imgRect.left + (point.x / img.naturalWidth) * imgRect.width;
                const pointScreenY = imgRect.top + (point.y / img.naturalHeight) * imgRect.height;
                
                console.log('Verificando punto ABSOLUTO V5:', {
                    pointId: point.id,
                    naturalCoords: { x: point.x, y: point.y },
                    screenCoords: { x: pointScreenX, y: pointScreenY },
                    imgRect
                });
                
                // Verificar si el punto está dentro del path (coordenadas de pantalla)
                if (pointInPolygon({ x: pointScreenX, y: pointScreenY }, path)) {
                    selectedSlabs.push(point.id);
                    point.isSelected = true;
                } else {
                    point.isSelected = false;
                }
            });
            
            updateSelectedCount();
            renderPoints();
            autoSaveCurrentImageData(); // AUTO-GUARDADO
        }
        
        function generateBatchCSV() {
            // Usar los mismos datos del histórico que se muestran en "Ver Histórico de Lotes"
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    if (data.data.length === 0) {
                        showAlert('No hay lotes en el histórico para exportar', 'error');
                        return;
                    }
                    
                    // Crear contenido CSV idéntico al del histórico
                    let csvContent = 'fecha,nombre_imagen,numero_lote,cantidad_slabs\n';
                    
                    // Ordenar por fecha descendente (igual que en la tabla histórica)
                    const datosOrdenados = data.data.sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
                    
                    datosOrdenados.forEach(registro => {
                        csvContent += `"${registro.fecha}","${registro.nombre_imagen}",${registro.numero_lote},${registro.cantidad_slabs}\n`;
                    });
                    
                    // Crear y descargar archivo
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    
                    if (link.download !== undefined) {
                        const url = URL.createObjectURL(blob);
                        link.setAttribute('href', url);
                        link.setAttribute('download', `historico_lotes_${new Date().toISOString().slice(0,10)}.csv`);
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    }
                    
                    showAlert(`✅ CSV del histórico exportado con ${data.data.length} registros`, 'success');
                } else {
                    showAlert('Error obteniendo datos del histórico: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Error descargando CSV del histórico:', error);
                showAlert('Error descargando CSV del histórico', 'error');
            });
        }
        
        function deleteBatch(batchNumber) {
            if (!currentActiveImage || !currentActiveImage.batches) {
                showAlert('❌ No hay imagen activa o no hay lotes', 'error');
                return;
            }
            
            if (!confirm(`¿Estás seguro de eliminar el Lote ${batchNumber}?`)) {
                return;
            }
            
            // Encontrar y eliminar el lote
            const batchIndex = currentActiveImage.batches.findIndex(batch => batch.number === batchNumber);
            
            if (batchIndex === -1) {
                showAlert('❌ Lote no encontrado', 'error');
                return;
            }
            
            // Obtener puntos del lote a eliminar
            const batchToDelete = currentActiveImage.batches[batchIndex];
            const pointsToRemove = batchToDelete.points;
            
            // Remover el lote del array
            currentActiveImage.batches.splice(batchIndex, 1);
            
            // RESTAURAR los puntos/detecciones del lote a estado original (con confidence)
            if (currentActiveImage.manualPoints) {
                // Restaurar los puntos que estaban en ese lote a su estado original
                currentActiveImage.manualPoints.forEach(point => {
                    const wasInDeletedBatch = pointsToRemove.some(p => p.id === point.id);
                    if (wasInDeletedBatch) {
                        // Restaurar a estado original de detección
                        point.batchNumber = null;
                        point.isSelected = false;
                        point.isAssigned = false;
                        // Los puntos mantienen su confidence original
                    }
                });
            }
            
            // Actualizar variables globales si es la imagen activa - RESTAURAR PUNTOS
            if (manualPoints) {
                manualPoints.forEach(point => {
                    const wasInDeletedBatch = pointsToRemove.some(p => p.id === point.id);
                    if (wasInDeletedBatch) {
                        // Restaurar a estado original de detección
                        point.batchNumber = null;
                        point.isSelected = false;
                        point.isAssigned = false;
                        // Los puntos mantienen su confidence original
                    }
                });
            }
            
            // Actualizar array global de batches
            batches = currentActiveImage.batches || [];
            
            // Guardar cambios
            autoSaveCurrentImageData();
            
            // Actualizar visualización
            renderPoints();
            updateActiveImageInfo();
            updateImagesGrid();
            
            // Sincronizar eliminación con histórico
            sincronizarEliminacionLoteHistorico(currentImageName || 'imagen_sin_nombre', batchNumber);
            
            showAlert(`✅ Lote ${batchNumber} eliminado correctamente`, 'success');
        }
        
        // ===== FUNCIONES PARA MODAL DE LOTE =====
        
        function openBatchModal() {
            const selectedPoints = manualPoints.filter(point => point.isSelected);
            
            if (selectedPoints.length === 0) {
                showAlert('❌ Primero selecciona slabs usando selección libre', 'error');
                return;
            }
            
            // Actualizar contador en modal
            document.getElementById('modalSelectedCount').textContent = selectedPoints.length;
            
            // Usar el último número de lote ingresado + 1
            let nextNumber = lastBatchNumber + 1;
            
            // Configurar modal centrado
            const modal = document.getElementById('batchModal');
            document.getElementById('modalBatchNumber').value = nextNumber;
            modal.style.display = 'flex';
            modal.classList.add('centered');
            
            // Focus en input para usabilidad
            setTimeout(() => {
                document.getElementById('modalBatchNumber').focus();
                document.getElementById('modalBatchNumber').select();
            }, 100);
        }
        
        function closeBatchModal() {
            const modal = document.getElementById('batchModal');
            modal.style.display = 'none';
            modal.classList.remove('centered');
        }
        
        async function confirmBatchAssignment() {
            const batchNumber = parseInt(document.getElementById('modalBatchNumber').value);
            
            // Validar número
            if (!batchNumber || batchNumber < 1) {
                showAlert('❌ Por favor ingresa un número válido', 'error');
                return;
            }
            
            console.log(`🎯 [confirmBatchAssignment] Usuario confirma creación de lote ${batchNumber}`);
            
            // VERIFICAR DUPLICADOS USANDO EL GESTOR CENTRALIZADO
            const resultado = await historialManager.verificarLoteDuplicado(batchNumber);
            console.log(`📋 [confirmBatchAssignment] Resultado de verificación:`, resultado);
            
            // Función para continuar con la creación del lote
            const continuarCreacion = () => {
                // Actualizar último número de lote ingresado
                lastBatchNumber = batchNumber;
                
                // Cerrar modal
                closeBatchModal();
                
                // Ejecutar asignación usando la función existente pero con el número del modal
                assignBatchToSelectedWithNumber(batchNumber);
            };
            
            if (resultado.existe) {
                console.log(`🚨 [confirmBatchAssignment] MOSTRANDO MODAL DUPLICADO: Lote ${batchNumber} ya existe`);
                // Mostrar modal de duplicado y esperar confirmación del usuario
                mostrarModalDuplicado(batchNumber, resultado, continuarCreacion);
            } else {
                console.log(`✅ [confirmBatchAssignment] Lote ${batchNumber} es único, continuando con creación`);
                continuarCreacion();
            }
        }
        
        // Función auxiliar que usa el número del modal
        async function assignBatchToSelectedWithNumber(batchNumber) {
            const selectedPoints = manualPoints.filter(point => point.isSelected);
            
            if (selectedPoints.length === 0) {
                showAlert('❌ No hay slabs seleccionados', 'error');
                return;
            }
            
            // REORGANIZACIÓN INTELIGENTE: Detectar lotes afectados y manejar selección parcial
            const affectedBatches = new Set();
            const batchPointCounts = new Map(); // Para contar puntos por lote
            const selectedPointsFromBatches = new Map(); // Para contar puntos seleccionados por lote
            
            // Contar puntos totales y seleccionados por lote
            manualPoints.forEach(point => {
                if (point.batchNumber !== null && point.batchNumber !== undefined) {
                    // Contar puntos totales del lote
                    batchPointCounts.set(point.batchNumber, (batchPointCounts.get(point.batchNumber) || 0) + 1);
                    
                    // Si este punto está seleccionado, contarlo
                    if (point.isSelected) {
                        affectedBatches.add(point.batchNumber);
                        selectedPointsFromBatches.set(point.batchNumber, (selectedPointsFromBatches.get(point.batchNumber) || 0) + 1);
                    }
                }
            });
            
            // Procesar lotes afectados
            if (affectedBatches.size > 0) {
                console.log(`🔄 REORGANIZACIÓN INTELIGENTE: ${affectedBatches.size} lote(s) afectado(s)`);
                
                const reorganizationMessages = [];
                
                affectedBatches.forEach(batchNum => {
                    const totalPoints = batchPointCounts.get(batchNum) || 0;
                    const selectedFromThisBatch = selectedPointsFromBatches.get(batchNum) || 0;
                    const remainingPoints = totalPoints - selectedFromThisBatch;
                    
                    console.log(`   Lote ${batchNum}: ${selectedFromThisBatch}/${totalPoints} seleccionados, ${remainingPoints} quedan`);
                    
                    if (remainingPoints === 0) {
                        // Todo el lote fue seleccionado - eliminar lote completo
                        batches = batches.filter(batch => batch.number !== batchNum);
                        reorganizationMessages.push(`Lote ${batchNum} eliminado completamente (todos los puntos seleccionados)`);
                        
                        // Sincronizar eliminación con base de datos histórica usando gestor centralizado
                        historialManager.eliminarLoteDelHistorial(currentImageName || 'imagen_sin_nombre', batchNum);
                    } else {
                        // Selección parcial - actualizar lote existente para mantener solo puntos no seleccionados
                        const batchToUpdate = batches.find(batch => batch.number === batchNum);
                        if (batchToUpdate) {
                            // Mantener solo los puntos que NO fueron seleccionados
                            batchToUpdate.points = batchToUpdate.points.filter(batchPoint => {
                                const correspondingPoint = manualPoints.find(mp => mp.id === batchPoint.id);
                                return correspondingPoint && !correspondingPoint.isSelected;
                            });
                            reorganizationMessages.push(`Lote ${batchNum} actualizado: ${remainingPoints} puntos mantenidos, ${selectedFromThisBatch} movidos al nuevo lote`);
                            
                            // Sincronizar actualización de cantidad con base de datos histórica usando gestor centralizado
                            historialManager.actualizarLoteEnHistorial(currentImageName || 'imagen_sin_nombre', batchNum, batchNum, remainingPoints);
                        }
                    }
                });
                
                // Limpiar batchNumber solo de los puntos seleccionados
                selectedPoints.forEach(point => {
                    if (point.batchNumber !== null && point.batchNumber !== undefined) {
                        point.batchNumber = null;
                    }
                });
                
                // Actualizar referencia
                currentActiveImage.batches = batches;
                
                // Mostrar mensaje de reorganización
                showAlert(
                    `🔄 Reorganización inteligente completada:\n${reorganizationMessages.join('\n')}`,
                    'warning'
                );
            }
            
            // Crear el lote directamente - la verificación ya se hizo en confirmBatchAssignment
            await crearNuevoLoteConPuntos(batchNumber, selectedPoints);
        }
        
        
        async function crearNuevoLoteConPuntos(batchNumber, selectedPoints) {
            // Crear nuevo lote
            const newBatch = {
                number: batchNumber,
                points: selectedPoints.map(point => ({
                    id: point.id,
                    x: point.x,
                    y: point.y
                })),
                createdAt: new Date().toISOString(),
                color: getBatchColor(batchNumber),
                imageName: currentImageName
            };
            
            // Agregar lote
            batches.push(newBatch);
            
            // Actualizar puntos seleccionados con el nuevo lote
            selectedPoints.forEach(point => {
                point.batchNumber = batchNumber;
                point.isSelected = false;
            });
            
            // Limpiar selección
            clearSelection();
            
            // Actualizar interfaz
            renderPoints();
            updateActiveImageInfo();
            
            // Guardar cambios
            autoSaveCurrentImageData();
            updateImagesGrid();
            
            // Guardar en historial CSV usando el gestor centralizado
            const guardadoExitoso = await historialManager.guardarLoteEnHistorial(
                currentImageName || 'imagen_sin_nombre', 
                batchNumber, 
                newBatch.points.length
            );
            
            if (guardadoExitoso) {
                showAlert(`✅ Lote ${batchNumber} creado con ${newBatch.points.length} slabs y guardado en historial`, 'success');
            } else {
                showAlert(`⚠️ Lote ${batchNumber} creado con ${newBatch.points.length} slabs pero hubo error guardando en historial`, 'warning');
            }
        }
        
        // ===== GESTOR CENTRALIZADO DE HISTORIAL CSV =====
        
        class HistorialManager {
            constructor() {
                this.cache = new Map(); // Cache local para evitar múltiples consultas
                this.lastUpdate = null;
            }
            
            async obtenerHistorialCompleto() {
                try {
                    const response = await fetch('/obtener_datos_historicos');
                    const data = await response.json();
                    
                    if (data.success) {
                        // Actualizar cache
                        this.cache.clear();
                        data.data.forEach(registro => {
                            const key = `${registro.numero_lote}`;
                            if (!this.cache.has(key)) {
                                this.cache.set(key, []);
                            }
                            this.cache.get(key).push(registro);
                        });
                        this.lastUpdate = Date.now();
                        console.log(`📊 Cache de historial actualizado: ${data.data.length} registros, ${this.cache.size} lotes únicos`);
                        return data.data;
                    } else {
                        console.error('❌ Error obteniendo historial:', data.error);
                        return [];
                    }
                } catch (error) {
                    console.error('❌ Error de conexión al obtener historial:', error);
                    return [];
                }
            }
            
            async verificarLoteDuplicado(numeroLote, imagenActualAExcluir = null) {
                console.log(`🔍 Verificando duplicado para lote ${numeroLote}${imagenActualAExcluir ? ` (excluyendo imagen: ${imagenActualAExcluir})` : ''}`);
                
                // Obtener historial actualizado
                await this.obtenerHistorialCompleto();
                
                // Buscar en cache
                let registrosDelLote = this.cache.get(String(numeroLote)) || [];
                
                // FILTRAR registros que NO sean de la imagen actual (cuando estamos editando un lote existente)
                if (imagenActualAExcluir) {
                    registrosDelLote = registrosDelLote.filter(registro => 
                        registro.nombre_imagen !== imagenActualAExcluir
                    );
                    console.log(`📋 Después de filtrar imagen ${imagenActualAExcluir}: ${registrosDelLote.length} registros restantes`);
                }
                
                if (registrosDelLote && registrosDelLote.length > 0) {
                    // Encontrar el registro más reciente
                    const registroMasReciente = registrosDelLote.reduce((mas_reciente, actual) => {
                        return new Date(actual.fecha) > new Date(mas_reciente.fecha) ? actual : mas_reciente;
                    });
                    
                    console.log(`⚠️ Lote ${numeroLote} encontrado en historial:`, registroMasReciente);
                    return {
                        existe: true,
                        ubicacion: `${registroMasReciente.nombre_imagen} (histórico)`,
                        ultimaFecha: registroMasReciente.fecha,
                        ultimaCantidad: registroMasReciente.cantidad_slabs,
                        totalOcurrencias: registrosDelLote.length
                    };
                } else {
                    console.log(`✅ Lote ${numeroLote} NO encontrado en historial${imagenActualAExcluir ? ' (excluyendo imagen actual)' : ''}`);
                    return {
                        existe: false,
                        ubicacion: null
                    };
                }
            }
            
            async guardarLoteEnHistorial(nombreImagen, numeroLote, cantidadSlabs) {
                console.log(`💾 Guardando en historial: ${nombreImagen} - Lote ${numeroLote} - ${cantidadSlabs} slabs`);
                
                try {
                    const response = await fetch('/guardar_lote_historico', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            nombre_imagen: nombreImagen,
                            numero_lote: numeroLote,
                            cantidad_slabs: cantidadSlabs
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('✅ Lote guardado exitosamente en historial');
                        // Invalidar cache para forzar actualización en próxima consulta
                        this.cache.clear();
                        return true;
                    } else {
                        console.error('❌ Error guardando lote:', data.error);
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Error de conexión guardando lote:', error);
                    return false;
                }
            }
            
            async eliminarLoteDelHistorial(nombreImagen, numeroLote) {
                console.log(`🗑️ Eliminando del historial: ${nombreImagen} - Lote ${numeroLote}`);
                
                try {
                    // Obtener todos los registros para encontrar el específico a eliminar
                    const historial = await this.obtenerHistorialCompleto();
                    const registroAEliminar = historial.find(r => 
                        r.nombre_imagen === nombreImagen && 
                        parseInt(r.numero_lote) === parseInt(numeroLote)
                    );
                    
                    if (!registroAEliminar) {
                        console.warn(`⚠️ No se encontró registro a eliminar: ${nombreImagen} - Lote ${numeroLote}`);
                        return false;
                    }
                    
                    const response = await fetch('/eliminar_registro_historico', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            fecha_original: registroAEliminar.fecha
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('✅ Registro eliminado exitosamente del historial');
                        this.cache.clear();
                        return true;
                    } else {
                        console.error('❌ Error eliminando registro:', data.error);
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Error eliminando del historial:', error);
                    return false;
                }
            }
            
            async actualizarLoteEnHistorial(nombreImagen, numeroLoteAnterior, numeroLoteNuevo, cantidadSlabs) {
                console.log(`🔄 Actualizando historial: ${nombreImagen} - ${numeroLoteAnterior} → ${numeroLoteNuevo} (${cantidadSlabs} slabs)`);
                
                try {
                    const response = await fetch('/sincronizar_lotes_historico', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            nombre_imagen: nombreImagen,
                            numero_lote_anterior: numeroLoteAnterior,
                            numero_lote_nuevo: numeroLoteNuevo,
                            cantidad_slabs: cantidadSlabs
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log('✅ Lote actualizado exitosamente en historial');
                        this.cache.clear();
                        return true;
                    } else {
                        console.error('❌ Error actualizando lote:', data.error);
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Error actualizando historial:', error);
                    return false;
                }
            }
        }
        
        // Instancia global del gestor de historial
        const historialManager = new HistorialManager();
        
        // ===== FUNCIÓN DE TEST PARA VERIFICAR SISTEMA ROBUSTO =====
        
        async function testSistemaHistorial() {
            console.log('🧪 === INICIANDO TEST DEL SISTEMA DE HISTORIAL ROBUSTO ===');
            
            try {
                // Test 1: Verificar lote que sabemos que existe (7777)
                console.log('🧪 Test 1: Verificando lote 7777 (debe existir)');
                const resultado7777 = await historialManager.verificarLoteDuplicado(7777);
                console.log('🧪 Resultado:', resultado7777);
                
                if (resultado7777.existe) {
                    showAlert(`✅ TEST PASADO: Lote 7777 encontrado en "${resultado7777.ubicacion}"`, 'success');
                } else {
                    showAlert(`❌ TEST FALLIDO: Lote 7777 debería existir pero no se encontró`, 'error');
                }
                
                // Test 2: Verificar lote que no existe
                console.log('🧪 Test 2: Verificando lote 999999 (no debe existir)');
                const resultado999999 = await historialManager.verificarLoteDuplicado(999999);
                console.log('🧪 Resultado:', resultado999999);
                
                if (!resultado999999.existe) {
                    showAlert(`✅ TEST PASADO: Lote 999999 correctamente no encontrado`, 'success');
                } else {
                    showAlert(`❌ TEST FALLIDO: Lote 999999 no debería existir`, 'error');
                }
                
                // Test 3: Verificar cache
                console.log('🧪 Test 3: Verificando cache del gestor');
                console.log(`📊 Cache contiene ${historialManager.cache.size} lotes únicos`);
                
                if (historialManager.cache.size > 0) {
                    showAlert(`✅ TEST PASADO: Cache funciona correctamente (${historialManager.cache.size} lotes)`, 'success');
                } else {
                    showAlert(`⚠️ Cache vacío - puede ser normal si no hay datos`, 'warning');
                }
                
                console.log('🧪 === TEST DEL SISTEMA DE HISTORIAL COMPLETADO ===');
                
            } catch (error) {
                console.error('❌ Error en test del sistema:', error);
                showAlert(`❌ ERROR EN TEST: ${error.message}`, 'error');
            }
        }
        
        // ===== FUNCIONES DE BASE DE DATOS HISTÓRICA =====
        
        function guardarEnBaseDatosHistorica(nombreImagen, numeroLote, cantidadSlabs) {
            fetch('/guardar_lote_historico', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    nombre_imagen: nombreImagen,
                    numero_lote: numeroLote,
                    cantidad_slabs: cantidadSlabs
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('📊 Lote guardado en base de datos histórica:', data.message);
                } else {
                    console.error('❌ Error guardando en base de datos:', data.error);
                }
            })
            .catch(error => {
                console.error('❌ Error en petición a base de datos:', error);
            });
        }
        
        function mostrarTablaHistorica() {
            console.log('📊 Cargando tabla histórica...');
            
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    llenarTablaHistorica(data.data);
                    
                    // Mostrar modal centrado
                    const modal = document.getElementById('tablaHistoricaModal');
                    modal.style.display = 'flex';
                    modal.classList.add('centered');
                    
                    // Configurar listener para ESC
                    configurarCierreConESC();
                    
                    // Configurar filtros en tiempo real después de mostrar el modal
                    setTimeout(() => configurarFiltrosHistorico(), 100);
                } else {
                    showAlert('❌ Error cargando datos históricos: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('❌ Error cargando datos históricos:', error);
                showAlert('❌ Error de conexión al cargar datos históricos', 'error');
            });
        }
        
        // Variable global para almacenar todos los datos históricos
        let datosHistoricoCompletos = [];
        
        function llenarTablaHistorica(datos) {
            // Almacenar datos completos para filtrado
            datosHistoricoCompletos = datos;
            
            // Aplicar filtros
            const datosFiltrados = aplicarFiltrosHistorico(datos);
            
            const tbody = document.getElementById('tablaHistoricaBody');
            const contador = document.getElementById('contadorRegistros');
            tbody.innerHTML = '';
            
            if (datosFiltrados.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px; color: #999;">No hay datos que coincidan con los filtros</td></tr>';
                contador.innerHTML = `Mostrando 0 de ${datos.length} registros`;
                return;
            }
            
            // Ordenar por fecha descendente (más reciente primero) con manejo de errores
            datosFiltrados.sort((a, b) => {
                try {
                    const fechaA = a.fecha ? new Date(a.fecha) : new Date(0);
                    const fechaB = b.fecha ? new Date(b.fecha) : new Date(0);
                    return fechaB - fechaA;
                } catch (error) {
                    console.warn('Error ordenando fechas:', error);
                    return 0;
                }
            });
            
            datosFiltrados.forEach(registro => {
                const row = tbody.insertRow();
                row.style.borderBottom = '1px solid #eee';
                
                // Formatear fecha
                const fecha = new Date(registro.fecha);
                const fechaFormateada = fecha.toLocaleDateString() + ' ' + fecha.toLocaleTimeString();
                
                // Crear celdas individualmente para añadir funcionalidad de edición
                const celdaFecha = row.insertCell();
                celdaFecha.style.cssText = 'padding: 8px; border: 1px solid #ddd; background: #f0f0f0;';
                celdaFecha.textContent = fechaFormateada;
                celdaFecha.title = 'La fecha no es editable';
                
                const celdaImagen = row.insertCell();
                celdaImagen.style.cssText = 'padding: 8px; border: 1px solid #ddd;';
                celdaImagen.textContent = registro.nombre_imagen;
                
                const celdaLote = row.insertCell();
                celdaLote.style.cssText = 'padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;';
                celdaLote.textContent = registro.numero_lote;
                
                const celdaSlabs = row.insertCell();
                celdaSlabs.style.cssText = 'padding: 8px; border: 1px solid #ddd; text-align: center;';
                celdaSlabs.textContent = registro.cantidad_slabs;
                
                // Alternar color de filas
                if (tbody.children.length % 2 === 0) {
                    row.style.backgroundColor = '#f8f9fa';
                }
            });
            
            // Actualizar contador
            contador.innerHTML = `Mostrando ${datosFiltrados.length} de ${datos.length} registros`;
            
            console.log(`📊 Tabla histórica cargada con ${datosFiltrados.length} registros filtrados de ${datos.length} totales`);
        }
        
        function aplicarFiltrosHistorico(datos) {
            const filtroImagen = document.getElementById('filtroImagen').value.toLowerCase().trim();
            const filtroLote = document.getElementById('filtroLote').value.trim();
            const filtroFechaDesde = document.getElementById('filtroFechaDesde').value;
            const filtroFechaHasta = document.getElementById('filtroFechaHasta').value;
            
            return datos.filter(registro => {
                // Filtro por imagen
                if (filtroImagen && !registro.nombre_imagen.toLowerCase().includes(filtroImagen)) {
                    return false;
                }
                
                // Filtro por número de lote
                if (filtroLote && registro.numero_lote.toString() !== filtroLote) {
                    return false;
                }
                
                // Filtro por rango de fechas
                const fechaRegistro = new Date(registro.fecha);
                if (filtroFechaDesde) {
                    const fechaDesde = new Date(filtroFechaDesde);
                    if (fechaRegistro < fechaDesde) {
                        return false;
                    }
                }
                
                if (filtroFechaHasta) {
                    const fechaHasta = new Date(filtroFechaHasta);
                    fechaHasta.setHours(23, 59, 59, 999); // Final del día
                    if (fechaRegistro > fechaHasta) {
                        return false;
                    }
                }
                
                return true;
            });
        }
        
        function limpiarFiltrosHistorico() {
            document.getElementById('filtroImagen').value = '';
            document.getElementById('filtroLote').value = '';
            document.getElementById('filtroFechaDesde').value = '';
            document.getElementById('filtroFechaHasta').value = '';
            
            // Recargar tabla sin filtros
            llenarTablaHistorica(datosHistoricoCompletos);
        }
        
        // Configurar event listeners para filtros en tiempo real
        function configurarFiltrosHistorico() {
            const filtroImagen = document.getElementById('filtroImagen');
            const filtroLote = document.getElementById('filtroLote');
            const filtroFechaDesde = document.getElementById('filtroFechaDesde');
            const filtroFechaHasta = document.getElementById('filtroFechaHasta');
            
            // Aplicar filtros con debounce para mejorar rendimiento
            let timeoutId;
            const aplicarFiltrosConDebounce = () => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    llenarTablaHistorica(datosHistoricoCompletos);
                }, 300);
            };
            
            if (filtroImagen) filtroImagen.addEventListener('input', aplicarFiltrosConDebounce);
            if (filtroLote) filtroLote.addEventListener('input', aplicarFiltrosConDebounce);
            if (filtroFechaDesde) filtroFechaDesde.addEventListener('change', () => llenarTablaHistorica(datosHistoricoCompletos));
            if (filtroFechaHasta) filtroFechaHasta.addEventListener('change', () => llenarTablaHistorica(datosHistoricoCompletos));
        }
        
        function cerrarTablaHistorica() {
            document.getElementById('tablaHistoricaModal').style.display = 'none';
            document.getElementById('tablaHistoricaModal').classList.remove('centered');
            
            // Remover listener de ESC
            document.removeEventListener('keydown', historialESCListener);
        }
        
        // ===== FUNCIONES PARA MODAL DE LOTES DUPLICADOS =====
        
        function mostrarModalDuplicado(numeroLote, resultado, callback) {
            // Llenar detalles del duplicado
            const detallesDiv = document.getElementById('duplicadoDetalles');
            detallesDiv.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>🏷️ Número de Lote:</strong> ${numeroLote}</div>
                <div style="margin-bottom: 8px;"><strong>📁 Imagen:</strong> ${resultado.ubicacion.replace(' (histórico)', '')}</div>
                <div style="margin-bottom: 8px;"><strong>📊 Cantidad de Slabs:</strong> ${resultado.ultimaCantidad}</div>
                <div style="margin-bottom: 8px;"><strong>📅 Última Fecha:</strong> ${new Date(resultado.ultimaFecha).toLocaleString()}</div>
                <div style="margin-bottom: 8px;"><strong>🔢 Total de Usos:</strong> ${resultado.totalOcurrencias}</div>
            `;
            
            // Configurar botón OK
            const okBtn = document.getElementById('duplicadoOkBtn');
            okBtn.onclick = function() {
                cerrarModalDuplicado();
                if (callback) callback();
            };
            
            // Mostrar modal
            document.getElementById('duplicadoModal').style.display = 'flex';
            
            // Configurar ESC para cerrar
            const escListener = function(e) {
                if (e.key === 'Escape') {
                    cerrarModalDuplicado();
                    if (callback) callback();
                    document.removeEventListener('keydown', escListener);
                }
            };
            document.addEventListener('keydown', escListener);
        }
        
        function cerrarModalDuplicado() {
            document.getElementById('duplicadoModal').style.display = 'none';
        }
        
        // ===== FUNCIÓN PARA CIERRE CON ESC =====
        
        let historialESCListener = null;
        
        function configurarCierreConESC() {
            // Remover listener anterior si existe
            if (historialESCListener) {
                document.removeEventListener('keydown', historialESCListener);
            }
            
            // Crear nuevo listener
            historialESCListener = function(e) {
                if (e.key === 'Escape') {
                    const modal = document.getElementById('tablaHistoricaModal');
                    if (modal && modal.style.display === 'block') {
                        cerrarTablaHistorica();
                    }
                }
            };
            
            // Agregar listener
            document.addEventListener('keydown', historialESCListener);
        }
        
        function descargarCSVHistorico() {
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Crear contenido CSV
                    let csvContent = 'fecha,nombre_imagen,numero_lote,cantidad_slabs\n';
                    
                    // Ordenar por fecha descendente
                    const datosOrdenados = data.data.sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
                    
                    datosOrdenados.forEach(registro => {
                        csvContent += `"${registro.fecha}","${registro.nombre_imagen}",${registro.numero_lote},${registro.cantidad_slabs}\n`;
                    });
                    
                    // Crear y descargar archivo
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const link = document.createElement('a');
                    const url = URL.createObjectURL(blob);
                    
                    link.setAttribute('href', url);
                    link.setAttribute('download', `historico_lotes_${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    showAlert('✅ CSV histórico descargado exitosamente', 'success');
                } else {
                    showAlert('❌ Error descargando CSV: ' + data.error, 'error');
                }
            })
            .catch(error => {
                console.error('❌ Error descargando CSV:', error);
                showAlert('❌ Error de conexión al descargar CSV', 'error');
            });
        }
        
        // ===== FUNCIONES DE EDICIÓN REMOVIDAS =====
        // La tabla histórica ya no es editable por diseño
        
        // ===== FUNCIÓN PARA EDITAR NÚMEROS DE LOTE EN PANEL ACTIVO =====
        
        async function editarNumeroLote(numeroLoteActual) {
            console.log(`✏️ Iniciando edición de lote ${numeroLoteActual}`);
            
            // Buscar el elemento span editable
            const spanElement = document.querySelector(`[data-batch-id="${numeroLoteActual}"]`);
            if (!spanElement) {
                showAlert('❌ Error: No se encontró el elemento a editar', 'error');
                return;
            }
            
            const valorOriginal = numeroLoteActual;
            
            // Crear input para edición
            const input = document.createElement('input');
            input.type = 'number';
            input.value = valorOriginal;
            input.min = '1';
            input.step = '1';
            input.style.cssText = `
                width: 60px; 
                border: 2px solid #1947BA; 
                padding: 2px 4px; 
                font-size: 12px; 
                text-align: center;
                border-radius: 4px;
                background: white;
            `;
            
            // Reemplazar contenido del span
            spanElement.innerHTML = '';
            spanElement.appendChild(input);
            input.focus();
            input.select();
            
            // Función para guardar cambios
            const guardarCambios = async () => {
                const nuevoNumero = parseInt(input.value);
                
                // Validaciones
                if (!nuevoNumero || nuevoNumero < 1) {
                    showAlert('❌ El número de lote debe ser mayor a 0', 'error');
                    input.focus();
                    return;
                }
                
                if (nuevoNumero === valorOriginal) {
                    // Sin cambios
                    cancelarEdicion();
                    return;
                }
                
                console.log(`💾 Guardando cambio: ${valorOriginal} → ${nuevoNumero}`);
                console.log(`📷 Imagen actual para excluir: ${currentImageName || 'imagen_sin_nombre'}`);
                
                try {
                    // VERIFICAR DUPLICADOS ANTES DE CAMBIAR (excluyendo la imagen actual)
                    const resultado = await historialManager.verificarLoteDuplicado(
                        nuevoNumero, 
                        currentImageName || 'imagen_sin_nombre'
                    );
                    
                    const continuarCambio = async () => {
                        // Actualizar el lote en la estructura de datos
                        const success = await actualizarNumeroLoteEnEstructura(valorOriginal, nuevoNumero);
                        
                        if (success) {
                            // Actualizar interfaz
                            spanElement.innerHTML = nuevoNumero;
                            spanElement.setAttribute('data-batch-id', nuevoNumero);
                            spanElement.onclick = () => editarNumeroLote(nuevoNumero);
                            
                            // Actualizar toda la interfaz para reflejar el cambio
                            renderPoints();
                            updateActiveImageInfo();
                            autoSaveCurrentImageData();
                            updateImagesGrid();
                            
                            showAlert(`✅ Lote actualizado: ${valorOriginal} → ${nuevoNumero}`, 'success');
                        } else {
                            cancelarEdicion();
                        }
                    };
                    
                    if (resultado.existe) {
                        console.log(`🚨 Lote ${nuevoNumero} ya existe, mostrando modal`);
                        mostrarModalDuplicado(nuevoNumero, resultado, continuarCambio);
                    } else {
                        await continuarCambio();
                    }
                    
                } catch (error) {
                    console.error('❌ Error editando número de lote:', error);
                    showAlert('❌ Error al actualizar el lote', 'error');
                    cancelarEdicion();
                }
            };
            
            // Función para cancelar edición
            const cancelarEdicion = () => {
                spanElement.innerHTML = valorOriginal;
                spanElement.onclick = () => editarNumeroLote(valorOriginal);
            };
            
            // Event listeners
            input.addEventListener('blur', guardarCambios);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    guardarCambios();
                } else if (e.key === 'Escape') {
                    cancelarEdicion();
                }
            });
        }
        
        async function actualizarNumeroLoteEnEstructura(numeroAnterior, numeroNuevo) {
            try {
                console.log(`🔍 Buscando lote ${numeroAnterior} en estructuras de datos...`);
                console.log(`📊 Batches globales:`, batches.map(b => ({ number: b.number, points: b.points.length })));
                console.log(`📷 Batches de imagen activa:`, currentActiveImage?.batches?.map(b => ({ number: b.number, points: b.points.length })));
                
                // BÚSQUEDA FLEXIBLE: buscar por numeroAnterior O numeroNuevo (en caso de que ya haya sido actualizado)
                let lote = null;
                let loteIndex = -1;
                let cantidadSlabs = 0;
                let loteEncontradoEn = '';
                
                // Buscar primero por numeroAnterior
                if (currentActiveImage && currentActiveImage.batches) {
                    loteIndex = currentActiveImage.batches.findIndex(batch => batch.number === numeroAnterior);
                    if (loteIndex !== -1) {
                        lote = currentActiveImage.batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'currentActiveImage.batches (por número anterior)';
                        console.log(`✅ Lote ${numeroAnterior} encontrado en currentActiveImage.batches`);
                    }
                }
                
                if (!lote) {
                    loteIndex = batches.findIndex(batch => batch.number === numeroAnterior);
                    if (loteIndex !== -1) {
                        lote = batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'batches globales (por número anterior)';
                        console.log(`✅ Lote ${numeroAnterior} encontrado en batches globales`);
                    }
                }
                
                // Si no se encontró por numeroAnterior, buscar por numeroNuevo (ya podría estar actualizado)
                if (!lote && currentActiveImage && currentActiveImage.batches) {
                    loteIndex = currentActiveImage.batches.findIndex(batch => batch.number === numeroNuevo);
                    if (loteIndex !== -1) {
                        lote = currentActiveImage.batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'currentActiveImage.batches (por número nuevo - ya actualizado)';
                        console.log(`✅ Lote ${numeroNuevo} encontrado en currentActiveImage.batches (ya actualizado)`);
                    }
                }
                
                if (!lote) {
                    loteIndex = batches.findIndex(batch => batch.number === numeroNuevo);
                    if (loteIndex !== -1) {
                        lote = batches[loteIndex];
                        cantidadSlabs = lote.points.length;
                        loteEncontradoEn = 'batches globales (por número nuevo - ya actualizado)';
                        console.log(`✅ Lote ${numeroNuevo} encontrado en batches globales (ya actualizado)`);
                    }
                }
                
                // Si aún no se encuentra, intentar sincronizar solo con CSV
                if (!lote) {
                    console.warn(`⚠️ Lote ${numeroAnterior} NO encontrado en estructuras, pero continuando con sincronización CSV`);
                    // Asumir una cantidad por defecto basada en puntos manuales
                    cantidadSlabs = manualPoints.filter(p => p.batchNumber === numeroAnterior || p.batchNumber === numeroNuevo).length;
                    console.log(`📊 Cantidad estimada de slabs desde puntos manuales: ${cantidadSlabs}`);
                    
                    // Solo sincronizar CSV sin actualizar estructuras locales
                    const sincronizacionExitosa = await historialManager.actualizarLoteEnHistorial(
                        currentImageName || 'imagen_sin_nombre',
                        numeroAnterior,
                        numeroNuevo,
                        cantidadSlabs
                    );
                    
                    if (sincronizacionExitosa) {
                        console.log(`✅ Sincronización CSV exitosa sin actualizar estructuras locales`);
                        return true;
                    } else {
                        console.error(`❌ Error en sincronización CSV`);
                        return false;
                    }
                }
                
                console.log(`📍 Lote encontrado en: ${loteEncontradoEn}`);
                
                // Solo actualizar si el lote aún no tiene el número nuevo
                if (lote.number !== numeroNuevo) {
                    lote.number = numeroNuevo;
                    console.log(`✅ Número actualizado en lote encontrado: ${numeroAnterior} → ${numeroNuevo}`);
                } else {
                    console.log(`ℹ️ El lote ya tiene el número ${numeroNuevo}, omitiendo actualización local`);
                }
                
                // Actualizar en TODAS las estructuras para mantener consistencia
                // Batches globales
                batches.forEach(batch => {
                    if (batch.number === numeroAnterior) {
                        batch.number = numeroNuevo;
                        console.log(`✅ Actualizado lote en batches globales: ${numeroAnterior} → ${numeroNuevo}`);
                    }
                });
                
                // Batches de imagen activa
                if (currentActiveImage && currentActiveImage.batches) {
                    currentActiveImage.batches.forEach(batch => {
                        if (batch.number === numeroAnterior) {
                            batch.number = numeroNuevo;
                            console.log(`✅ Actualizado lote en currentActiveImage.batches: ${numeroAnterior} → ${numeroNuevo}`);
                        }
                    });
                }
                
                // Actualizar los puntos manuales que pertenecen a este lote
                let puntosActualizados = 0;
                manualPoints.forEach(point => {
                    if (point.batchNumber === numeroAnterior) {
                        point.batchNumber = numeroNuevo;
                        puntosActualizados++;
                    }
                });
                console.log(`✅ Actualizado ${puntosActualizados} puntos manuales: ${numeroAnterior} → ${numeroNuevo}`);
                
                // Sincronizar con el historial CSV usando el gestor centralizado
                const sincronizacionExitosa = await historialManager.actualizarLoteEnHistorial(
                    currentImageName || 'imagen_sin_nombre',
                    numeroAnterior,
                    numeroNuevo,
                    cantidadSlabs
                );
                
                if (!sincronizacionExitosa) {
                    console.warn('⚠️ Advertencia: Error sincronizando con historial CSV');
                    showAlert('⚠️ Lote actualizado localmente pero hubo error sincronizando con historial', 'warning');
                }
                
                console.log(`✅ Lote actualizado exitosamente: ${numeroAnterior} → ${numeroNuevo}`);
                return true;
                
            } catch (error) {
                console.error('❌ Error actualizando estructura de lote:', error);
                showAlert('❌ Error actualizando el lote', 'error');
                return false;
            }
        }
        
        // ===== FUNCIONES DE SINCRONIZACIÓN CON HISTÓRICO =====
        
        function sincronizarEliminacionLoteHistorico(nombreImagen, numeroLote) {
            // Eliminar registros del histórico que correspondan a este lote
            fetch('/obtener_datos_historicos')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Buscar registros del lote eliminado
                    const registrosAEliminar = data.data.filter(registro => 
                        registro.nombre_imagen === nombreImagen && 
                        parseInt(registro.numero_lote) === parseInt(numeroLote)
                    );
                    
                    // Eliminar cada registro encontrado
                    const promesasEliminacion = registrosAEliminar.map(registro => 
                        fetch('/eliminar_registro_historico', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                fecha_original: registro.fecha
                            })
                        })
                    );
                    
                    Promise.all(promesasEliminacion)
                    .then(() => {
                        console.log(`📊 Eliminados ${registrosAEliminar.length} registros del histórico para lote ${numeroLote}`);
                    })
                    .catch(error => {
                        console.error('❌ Error eliminando registros del histórico:', error);
                    });
                }
            })
            .catch(error => {
                console.error('❌ Error obteniendo datos para eliminar del histórico:', error);
            });
        }
        
        function sincronizarCambioLoteHistorico(nombreImagen, numeroLoteAnterior, numeroLoteNuevo, cantidadSlabs) {
            fetch('/sincronizar_lotes_historico', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    nombre_imagen: nombreImagen,
                    numero_lote_anterior: numeroLoteAnterior,
                    numero_lote_nuevo: numeroLoteNuevo,
                    cantidad_slabs: cantidadSlabs
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('📊 Lote sincronizado con histórico exitosamente');
                } else {
                    console.error('❌ Error sincronizando lote:', data.error);
                }
            })
            .catch(error => {
                console.error('❌ Error en sincronización de lote:', error);
            });
        }
        
        // Variables para sistema de guardado automático
        let autoSaveInterval = null;
        let lastAutoSaveTime = Date.now();
        let isAutoSaveActive = false;
        
        // Función para inicializar sistema de guardado automático
        function initAutoSaveSystem() {
            // Guardado cada 2 minutos si hay trabajo pendiente
            autoSaveInterval = setInterval(async () => {
                if (!currentActiveImage || !isAutoSaveActive) {
                    return;
                }
                
                // PREVENIR AUTO-GUARDADO INNECESARIO: Solo si hay datos significativos
                if (!hasSignificantData(currentActiveImage)) {
                    console.log(`🚫 AUTO-GUARDADO CANCELADO para ${currentActiveImage.name} - No hay datos significativos`);
                    return;
                }
                
                const hasWork = hasUnsavedWork();
                if (hasWork) {
                    console.log('🔄 Auto-guardado periódico iniciado...');
                    const result = await saveImageDataWithValidation(currentActiveImage);
                    
                    if (result.success) {
                        markSaveSuccess();
                        markCurrentImageAsSaved(); // Marcar imagen como guardada
                        showNotification('💾 Auto-guardado completado', 'info', 2000);
                        console.log('✅ Auto-guardado periódico exitoso');
                    } else {
                        console.log('❌ Auto-guardado periódico falló:', result.error);
                        showNotification('⚠️ Auto-guardado falló', 'warning', 3000);
                        
                        // Intentar respaldo forzado si el auto-guardado falla
                        setTimeout(() => {
                            forceBackup().then(success => {
                                if (success) {
                                    showNotification('✅ Respaldo de emergencia exitoso', 'success', 3000);
                                }
                            });
                        }, 5000);
                    }
                } else {
                    console.log('🔄 Auto-guardado omitido: no hay trabajo pendiente');
                }
            }, 120000); // 2 minutos
            
            console.log('⚙️ Sistema de auto-guardado inicializado (cada 2 minutos)');
        }
        
        // Función para activar/desactivar auto-guardado
        function setAutoSaveActive(active) {
            isAutoSaveActive = active;
            console.log(`🔄 Auto-guardado ${active ? 'activado' : 'desactivado'}`);
        }
        
        // Función para obtener estado del sistema de persistencia
        function getPersistenceSystemStatus() {
            const now = Date.now();
            const timeSinceLastSave = now - lastAutoSaveTime;
            const minutesSinceLastSave = Math.floor(timeSinceLastSave / 60000);
            
            return {
                autoSaveActive: isAutoSaveActive,
                lastSaveTime: new Date(lastAutoSaveTime).toLocaleTimeString(),
                minutesSinceLastSave: minutesSinceLastSave,
                hasCurrentWork: currentActiveImage ? hasUnsavedWork() : false,
                currentImage: currentActiveImage ? currentActiveImage.name : 'Ninguna'
            };
        }
        
        // Función para actualizar indicador visual de estado (simplificada)
        function updateSaveStatusIndicator() {
            const indicator = document.getElementById('saveStatusIndicator');
            const statusText = document.getElementById('saveStatusText');
            const lastSaveTimeEl = document.getElementById('lastSaveTime');
            
            if (!indicator || !statusText || !lastSaveTimeEl) return;
            
            // Mostrar indicador si hay imagen activa
            if (currentActiveImage) {
                indicator.style.display = 'block';
                
                let statusMessage = '';
                let borderColor = '#28a745'; // Verde por defecto
                let bgColor = 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)';
                
                const hasWork = (manualPoints && manualPoints.length > 0) || (batches && batches.length > 0);
                
                // Lógica SIMPLE: solo mostrar cambios pendientes si realmente los hay
                if (currentImageHasChanges && hasWork) {
                    statusMessage = '⚠️ Cambios pendientes de guardado';
                    borderColor = '#fd7e14'; // Naranja
                    bgColor = 'linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%)';
                } else if (hasWork) {
                    statusMessage = '✅ Trabajo guardado correctamente';
                    borderColor = '#28a745'; // Verde
                } else {
                    statusMessage = '✅ Sin trabajo pendiente';
                    borderColor = '#28a745'; // Verde
                }
                
                statusText.textContent = statusMessage;
                lastSaveTimeEl.textContent = `Último guardado: ${new Date(lastAutoSaveTime).toLocaleTimeString()}`;
                
                // Aplicar estilos
                indicator.style.borderLeftColor = borderColor;
                indicator.style.background = bgColor;
                
                // Debug
                console.log(`💾 Indicador actualizado: ${statusMessage} (cambios=${currentImageHasChanges}, trabajo=${hasWork})`);
                
            } else {
                indicator.style.display = 'none';
            }
        }
        
        // Función para marcar guardado exitoso
        function markSaveSuccess() {
            lastAutoSaveTime = Date.now();
            updateSaveStatusIndicator();
        }
        
        // Función de diagnóstico para debugging (disponible en consola)
        window.diagnosticSaveStatus = async function() {
            console.log('=== DIAGNÓSTICO DEL SISTEMA DE GUARDADO ===');
            
            // 1. Estado general
            const status = getPersistenceSystemStatus();
            console.log('1. Estado del sistema:', status);
            
            // 2. Imagen actual
            if (!currentActiveImage) {
                console.log('2. No hay imagen activa');
                return;
            }
            
            console.log('2. Imagen activa:', {
                name: currentActiveImage.name,
                manualPoints: manualPoints ? manualPoints.length : 0,
                batches: batches ? batches.length : 0,
                hasUnsavedWork: hasUnsavedWork(),
                hasUnsavedChanges: hasUnsavedChanges(),
                lastSavedState: lastSavedState,
                currentState: getCurrentImageState()
            });
            
            // 3. Probar conexión con servidor
            console.log('3. Probando conexión con servidor...');
            try {
                const response = await fetch('/load_persistent_data', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    console.log('   ✅ Conexión exitosa con servidor');
                } else {
                    console.log('   ❌ Error de conexión:', response.status);
                }
            } catch (error) {
                console.log('   ❌ Error de red:', error.message);
            }
            
            // 4. Probar guardado de prueba
            if (hasUnsavedWork()) {
                console.log('4. Probando guardado de la imagen actual...');
                const result = await saveImageDataWithValidation(currentActiveImage);
                console.log('   Resultado del guardado de prueba:', result);
            } else {
                console.log('4. No hay trabajo para probar guardado');
            }
            
            // 5. Consejos de solución
            console.log('5. POSIBLES SOLUCIONES:');
            console.log('   - Verificar que el servidor esté ejecutándose');
            console.log('   - Comprobar conexión a internet');
            console.log('   - Liberar espacio en disco si está lleno');
            console.log('   - Reiniciar el navegador si hay problemas de memoria');
            console.log('   - Ejecutar resetSaveSystem() para reiniciar el sistema');
            console.log('   - Como último recurso, usar "Forzar Respaldo" en la interfaz');
            
            console.log('=== FIN DEL DIAGNÓSTICO ===');
        };
        
        // Función para resetear el sistema de guardado (disponible en consola)
        window.resetSaveSystem = function() {
            console.log('🔄 Reseteando sistema de guardado...');
            lastAutoSaveTime = Date.now();
            isAutoSaveActive = true;
            updateSaveStatusIndicator();
            console.log('✅ Sistema de guardado reseteado');
        };
        
        // Función de debug para el sistema de persistencia (disponible en consola)
        window.checkPersistenceStatus = function() {
            console.log('=== ESTADO DE PERSISTENCIA ===');
            console.log('Imagen actual:', currentActiveImage?.name);
            console.log('Puntos:', manualPoints?.length || 0);
            console.log('Lotes:', batches?.length || 0);
            console.log('Imagen tiene cambios:', currentImageHasChanges);
            console.log('Último guardado:', new Date(lastAutoSaveTime).toLocaleTimeString());
            console.log('Auto-guardado activo:', isAutoSaveActive);
            
            const status = getPersistenceSystemStatus();
            console.log('Estado completo:', status);
        };
        
        // Función para forzar cambios (disponible en consola)
        window.forceChanges = function() {
            markCurrentImageAsChanged();
            console.log('Cambios forzados en imagen:', currentActiveImage?.name);
        };
        
        // Función para simular cambios (disponible en consola)
        window.simulateChanges = function() {
            if (currentActiveImage && manualPoints) {
                // Agregar un punto falso para simular cambios
                manualPoints.push({
                    id: 'test-' + Date.now(),
                    x: 100,
                    y: 100,
                    confidence: 0.99,
                    isSelected: false
                });
                console.log('🔄 Cambios simulados agregados');
                console.log('hasUnsavedChanges():', hasUnsavedChanges());
                renderPoints(); // Re-renderizar puntos
            } else {
                console.log('⚠️ No hay imagen activa para simular cambios');
            }
        };
        
        // Permitir confirmar con Enter en el modal
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializar sistema de auto-guardado
            initAutoSaveSystem();
            
            // Activar auto-guardado al cargar la página
            setAutoSaveActive(true);
            
            // Actualizar indicador de estado cada 30 segundos
            setInterval(() => {
                updateSaveStatusIndicator();
            }, 30000);
            
            // Navegación con flechas del teclado
            document.addEventListener('keydown', function(e) {
                // Solo activar si no hay modales abiertos y hay al menos 2 imágenes
                const modalsOpen = document.getElementById('batchModal').style.display === 'flex' ||
                                 document.getElementById('cleanDatabaseModal').style.display === 'flex' ||
                                 document.getElementById('duplicadoModal').style.display === 'flex' ||
                                 document.querySelector('.modal[style*="display: block"]') ||
                                 document.querySelector('.modal[style*="display: flex"]');
                
                if (modalsOpen || !uploadedImages || uploadedImages.length <= 1) return;
                
                // Prevenir comportamiento por defecto solo para las flechas que usamos
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    
                    if (e.key === 'ArrowLeft') {
                        previousImage();
                    } else if (e.key === 'ArrowRight') {
                        nextImage();
                    }
                }
            });
            
            document.getElementById('modalBatchNumber').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    confirmBatchAssignment();
                }
            });
            
            // Cerrar modal con Escape
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('batchModal').style.display === 'flex') {
                    closeBatchModal();
                }
            });
            
            // Mostrar estado del sistema en consola cada 5 minutos
            setInterval(() => {
                const status = getPersistenceSystemStatus();
                console.log('📊 Estado del sistema de persistencia:', status);
            }, 300000); // 5 minutos
        });
        
        // ===== FUNCIONES DE LIMPIEZA DE BASE DE DATOS =====
        
        function openCleanDatabaseModal() {
            try {
                console.log('🔄 Abriendo modal de limpieza...');
                const modal = document.getElementById('cleanDatabaseModal');
                if (!modal) {
                    console.error('❌ Modal cleanDatabaseModal no encontrado!');
                    return;
                }
                
                // Asegurar estado limpio antes de abrir
                modal.style.visibility = 'visible';
                modal.style.pointerEvents = 'auto';
                modal.style.display = 'flex';
                modal.classList.add('centered');
                
                console.log('✅ Modal abierto exitosamente');
            } catch (error) {
                console.error('❌ Error abriendo modal:', error);
            }
        }
        
        function closeCleanDatabaseModal() {
            try {
                console.log('🔄 Intentando cerrar modal de limpieza...');
                const modal = document.getElementById('cleanDatabaseModal');
                if (!modal) {
                    console.error('❌ Modal cleanDatabaseModal no encontrado!');
                    return;
                }
                
                // Limpiar todos los estados del modal
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.classList.remove('centered');
                
                // Asegurar que no hay eventos pendientes
                modal.style.pointerEvents = 'auto';
                
                console.log('✅ Modal cerrado exitosamente');
            } catch (error) {
                console.error('❌ Error cerrando modal:', error);
                // Fallback forzado
                try {
                    document.getElementById('cleanDatabaseModal').style.display = 'none';
                } catch (fallbackError) {
                    console.error('❌ Error en fallback:', fallbackError);
                }
            }
        }
        
        async function confirmCleanDatabase() {
            const selectedOption = document.querySelector('input[name="cleanOption"]:checked').value;
            const createBackup = document.getElementById('createBackupCheck').checked;
            
            // Mostrar confirmación adicional para opciones destructivas
            if (selectedOption === 'json_cleanup') {
                const confirmed = confirm('⚠️ ADVERTENCIA: Esta acción eliminará TODOS los datos JSON de persistencia. ¿Estás completamente seguro?');
                if (!confirmed) return;
            } else if (selectedOption === 'csv_cleanup') {
                const confirmed = confirm('⚠️ ADVERTENCIA: Esta acción eliminará TODO el histórico CSV. Los datos JSON se conservarán. ¿Continuar?');
                if (!confirmed) return;
            } else if (selectedOption === 'total_cleanup') {
                const confirmed = confirm('💥 ADVERTENCIA CRÍTICA: Esta acción eliminará TODOS los datos (JSON + CSV + Imágenes). Es un reseteo completo del sistema. ¿Estás COMPLETAMENTE seguro?');
                if (!confirmed) return;
            } else if (selectedOption === 'images_cleanup') {
                const confirmed = confirm('⚠️ ADVERTENCIA: Esta acción eliminará todas las imágenes subidas. Los datos JSON y CSV se conservarán. ¿Continuar?');
                if (!confirmed) return;
            }
            
            closeCleanDatabaseModal();
            
            try {
                // Crear respaldo automático si está marcado
                if (createBackup) {
                    showAlert('💾 Creando respaldo automático...', 'info');
                    const backupResult = await forceBackup();
                    if (!backupResult) {
                        showAlert('⚠️ Advertencia: No se pudo crear respaldo, pero continuando con limpieza', 'warning');
                    } else {
                        showAlert('✅ Respaldo creado exitosamente', 'success');
                    }
                }
                
                // Ejecutar limpieza
                showAlert('🗑️ Ejecutando limpieza de base de datos...', 'info');
                
                const response = await fetch('/clean_database', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        option: selectedOption,
                        create_backup: createBackup
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showAlert(`✅ Base de datos limpiada exitosamente: ${result.message}`, 'success');
                    
                    // Actualizar UI según la opción de limpieza
                    if (selectedOption === 'json_cleanup' || selectedOption === 'total_cleanup') {
                        // Limpiar toda la UI (JSON afectado)
                        uploadedImages = [];
                        currentActiveImage = null;
                        updateImagesGrid();
                        clearAllVisualElements();
                        
                        // Limpiar caché de datos históricos
                        datosHistoricoCompletos = [];
                        console.log('🗑️ Caché de histórico limpiado (limpieza completa)');
                        
                        // Si el modal de histórico está abierto, actualizarlo
                        const modalHistorico = document.getElementById('tablaHistoricaModal');
                        if (modalHistorico && modalHistorico.style.display === 'flex') {
                            console.log('🔄 Actualizando modal de histórico abierto...');
                            mostrarTablaHistorica(); // Re-fetch y mostrar datos actualizados
                        }
                    } else if (selectedOption === 'csv_cleanup') {
                        // Solo se limpió CSV, mantener UI actual
                        showAlert('ℹ️ Solo se eliminó el histórico CSV. Los datos de trabajo se conservan.', 'info');
                        
                        // Limpiar caché de datos históricos
                        datosHistoricoCompletos = [];
                        console.log('🗑️ Caché de histórico limpiado');
                        
                        // Si el modal de histórico está abierto, actualizarlo
                        const modalHistorico = document.getElementById('tablaHistoricaModal');
                        if (modalHistorico && modalHistorico.style.display === 'flex') {
                            console.log('🔄 Actualizando modal de histórico abierto...');
                            mostrarTablaHistorica(); // Re-fetch y mostrar datos actualizados
                            showAlert('✅ Histórico actualizado', 'success');
                        }
                    } else if (selectedOption === 'images_cleanup') {
                        // Solo se limpiaron imágenes, recargar para reflejar cambios
                        showAlert('ℹ️ Imágenes eliminadas. Recargando interfaz...', 'info');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        // Recargar imágenes para reflejar cambios
                        location.reload();
                    }
                } else {
                    showAlert(`❌ Error limpiando base de datos: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error limpiando base de datos:', error);
                showAlert('❌ Error de conexión al limpiar base de datos', 'error');
            }
        }
        
        async function cleanImageData(imageId) {
            const imageObj = uploadedImages.find(img => img.id === imageId);
            if (!imageObj) {
                showAlert('❌ Imagen no encontrada', 'error');
                return;
            }
            
            const confirmed = confirm(`¿Limpiar datos de persistencia para "${imageObj.name}"?\n\nEsto eliminará:\n• Puntos manuales\n• Lotes asignados\n• Datos de detección guardados`);
            if (!confirmed) return;
            
            try {
                showAlert(`🗑️ Limpiando datos de ${imageObj.name}...`, 'info');
                
                const response = await fetch('/clean_image_data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image_name: imageObj.name
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Limpiar datos locales de la imagen
                    imageObj.manualPoints = [];
                    imageObj.batches = [];
                    imageObj.detectionData = null;
                    imageObj.status = 'uploaded';
                    imageObj.nextPointId = 1;
                    
                    // Si es la imagen activa, limpiar variables globales también
                    if (currentActiveImage && currentActiveImage.id === imageId) {
                        manualPoints = [];
                        batches = [];
                        nextPointId = 1;
                        clearAllVisualElements();
                    }
                    
                    updateImagesGrid();
                    updateActiveImageInfo();
                    
                    showAlert(`✅ Datos de "${imageObj.name}" limpiados exitosamente`, 'success');
                } else {
                    showAlert(`❌ Error limpiando datos: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error limpiando datos de imagen:', error);
                showAlert('❌ Error de conexión al limpiar datos', 'error');
            }
        }
        
        // Función de emergencia para cerrar modal
        function forceCloseCleanDatabaseModal() {
            console.log('🚨 Forzando cierre de modal...');
            const modal = document.getElementById('cleanDatabaseModal');
            if (modal) {
                modal.style.display = 'none';
                modal.style.visibility = 'hidden';
                modal.classList.remove('centered');
                modal.style.pointerEvents = 'auto';
                console.log('✅ Modal forzado a cerrar');
            }
        }
        
        // Cerrar modal de limpieza con Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('cleanDatabaseModal');
                if (modal && (modal.style.display === 'flex' || modal.style.display === 'block')) {
                    closeCleanDatabaseModal();
                }
            }
        });
        
        // Click fuera del modal para cerrar
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('cleanDatabaseModal');
            if (modal && modal.style.display === 'flex' && e.target === modal) {
                closeCleanDatabaseModal();
            }
        });
        
    </script>
</body>
</html>